[{"title":"go搭建web项目（一）","date":"2023-12-26T13:02:57.000Z","url":"/posts/e1a1e4cd.html","tags":[["go系列","/tags/go%E7%B3%BB%E5%88%97/"]],"categories":[["go","/categories/go/"]],"content":"使用go搭建web项目，本篇文章主要是项目的初始化配置 1.项目初始化1.1目录结构 1.2初始化 执行该命令之后会在根目录下生成的一个包管理配置 go.mod之后我们需要新建一个入口文件 main.go 1.3引入gingin是一个go语言编写的web框架，使用gin可以快速搭建一个web项目 下面就使用gin来起一个服务 通过 go run main.go 就可以启动一个web服务。然后再浏览器输入localhost:8080/ping 就可以看到返回的 pong 2.配置初始化和全局变量配置文件是每个项目必不可缺的一个文件，这里我们使用 viper在管理我们的配置信息 2.1引入viper 然后在 config.yaml文件中添加配置 在 config 文件中存放所有配置的结构题，新建 config.go 文件定义 Configuration，其中App 属性对应 config.yaml 中的 app 新建 app.go 文件，定义App结构体，其所有属性分别对应 config.yaml 中 app 下的所有配置 2.2 将配置放入全局变量下面我们在 global 中创建一个 global.go 文件来集中存放全局变量： 实际工作中多环境开发、测试的场景，我们需要针对不同的环境使用不同的配置，在core中加入一个internal文件，添加一个constants.go，写入： 然后在 core 中新建 viper.go，编写配置初始化方法： 2.3使用配置现在我们已经将配置解析到了全局变量中，就可以将其使用到服务启动逻辑中了，在 core 中新建 server.go文件，然后将服务启动的方法写在这里： 是一个可以用于重新加载和优雅关闭HTTP服务器的库。它可以在运行时更新服务器代码而无需停止正在运行的HTTP服务器。这使得服务器能够在生产环境下无缝地进行更新和维护，同时不影响当前正在运行的请求和连接。 3.2定义配置项在 config.yarml 中新增日志配置： 然后新建 config/zap.go，在文件中增加对应的结构体和日志级别转换方法： 在 config.go 中加入 zap： 3.3日志初始化方法在 core 中新建 zap.go： 在 core/internal 中新建 zap.go和file_rotate_logs.go： 新建 utils/directory.go文件，编写 PathExists函数，用于判断路径是否存在： 3.4定义全局变量在 global/global.go 中，添加 Log 成员属性 最后修改 main.go文件，将刚才的配置信息初始化 "},{"title":"webpack","date":"2023-07-17T12:51:15.000Z","url":"/posts/b9f20a20.html","categories":[["react","/categories/react/"]],"content":"webpackwebpack简介webpack是一个用于现代JavaScript应用程序的静态模块打包工具。我们可以使用webpack管理模块。因为在webpack看来，项目中的所有资源皆为模块，通过分析模块间的依赖关系，在其内部构建出一个依赖图，最终编译输出为HTML、JavaScript、CSS以及各种静态文件（图片、字体），让我们开发的过程更加高效。 webpack的主要作用： 模块打包：可以将不同模块的文件打包整合在一起，并且保证他们之间的引用正确，执行有序。利用打包我们就可以在开发的时候根据我们自己的业务自由划分文件模块，保证项目结构的清晰和可读性 编译兼容”前端的“上古时期”，手写一堆浏览器兼容代码一直是令前端工程师头皮发麻的事情，而在今天这个问题被大大的弱化了，通过webpack的Loader机制，不仅仅可以帮助我们对代码做polyfill，还可以编译转换诸如.less，.vue，.jsx这类在浏览器无法识别的格式文件，让我们在开发的时候可以使用新特性和新语法做开发，提高开发效率。 能力扩展：通过webpack的Plugin机制，我们在实现模块化打包和编译兼容的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量。 webpack构建流程webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译 确定入口：根据配置中的 entry 找出所有的入口文件 编译模块：从入口文件出发，调用所有配置的 loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理 完成模块编译：在经过上一步使用 loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统 常见的loader image-loader：加载并且压缩图片文件。 less-loader： 加载并编译 LESS 文件。 sass-loader：加载并编译 SASS&#x2F;SCSS 文件。 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性，使用css-loader必须要配合使用+ style-loader。 style-loader：用于将 CSS 编译完成的样式，挂载到页面的 style 标签上。需要注意 loader 执行顺序，+ style-loader 要放在第一位，loader 都是从后往前执行。 babel-loader：把 ES6 转换成 ES5 postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀。 eslint-loader：通过 ESLint 检查 JavaScript 代码。 vue-loader：加载并编译 Vue 组件。 file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体) url-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)更多loader 常见的pluginwebpack中的plugin赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在webpack的不同阶段（钩子 &#x2F; 生命周期），贯穿了webpack整个编译周期。目的在于解决 loader 无法实现的其他事。常用的plugin如下： HtmlWebpackPlugin：简化 HTML 文件创建 (依赖于 html-loader) mini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin) clean-webpack-plugin: 目录清理更多plugin loader和plugin的区别loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中；plugin赋予了webpack各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader无法实现的其他事。在运行时机上，loader 运行在打包文件之前；plugin则是在整个编译周期都起作用。在配置上，loader在module.rules中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性；plugin在 plugins中单独配置，类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入。"},{"title":"网络篇","date":"2023-03-24T02:26:14.000Z","url":"/posts/608487bc.html","tags":[["面试题系列","/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B3%BB%E5%88%97/"]],"categories":[["面试题","/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"]],"content":"1.TCP连接的过程TCP协议铜鼓三次握手建立可靠的点对点连接： 首先服务器进入监听状态，然后即可处理连接 第一次握手：建立连接是，客户端发送syn包到服务器，并进入SYN_SENT状态，等待服务器确认。在发送的包中还会包含一个初始序列号seq。此次握手的含义是客户端希望与服务器建立连接 第二次握手：服务器收到syn包后，然后回应给客户端一个SYN-ACK包，此时服务器进入SYN_RCVD状态。此次握手的含义是服务端 回应客户端，表示已收到并同意客户端的链接请求 第三次握手：客户端收到服务器的SYN包后，向服务器再次发送ACK包，并进入ESTAB_LISHED 状态。最后，服务器端收到客户端的ACK包，于是也进入ESTAB_LISHED 状态，至此，连接建立完成 2.HTTPS 中间人攻击针对HTTPS共计主要有SSL劫持攻击和SSl剥离攻击两种 SSL 劫持攻击是指攻击者劫持了客户端和服务器之间的连接，将服务器的合法证书替换为伪造的证书，从而获取客户端和服务器之间传递的信息。这种方式一般容易被用户发现，浏览器会明确的提示证书错误，但某些用户安全意识不强，可能会点击继续浏览，从而达到攻击目的 SSL 剥离攻击是指攻击者劫持了客户端和服务器之间的连接，攻击者保持自己和服务器之间的 HTTPS 连接，但发送给客户端普通的 HTTP 连接，由于 HTTP 连接是明文传输的，即可获取客户端传输的所有明文数据。 3.http1.0、http1.1、http2.0 协议的区别？http1.0它的特点是每次请求和响应完毕后都会销毁 TCP 连接，同时规定前一个响应完成后才能发送下一个请求。这样做有两个问题： 无法复用连接每次请求都要创建新的 TCP 连接，完成三次握手和四次挥手，网络利用率低 队头阻塞如果前一个请求被某种原因阻塞了，会导致后续请求无法发送。 http1.1http1.1 是 http1.0 的改进版，它做出了以下改进： 长连接http1.1 允许在请求时增加请求头connection:keep-alive，这样便允许后续的客户端请求在一段时间内复用之前的 TCP 连接 管道化基于长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回。 缓存处理新增响应头 cache-control，用于实现客户端缓存。 断点传输在上传&#x2F;下载资源时，如果资源过大，将其分割为多个部分，分别上传&#x2F;下载，如果遇到网络故障，可以从已经上传&#x2F;下载好的地方继续请求，不用从头开始，提高效率 http2.0http2.0 进一步优化了传输效率，它主要有以下改进： 二进制分帧将传输的消息分为更小的二进制帧，每帧有自己的标识序号，即便被随意打乱也能在另一端正确组装 多路复用基于二进制分帧，在同一域名下所有访问都是从同一个 tcp 连接中走，并且不再有队头阻塞问题，也无须遵守响应顺序 头部压缩http2.0 通过字典的形式，将头部中的常见信息替换为更少的字符，极大的减少了头部的数据量，从而实现更小的传输量 服务器推http2.0 允许服务器直接推送消息给客户端，无须客户端明确的请求 3.四次挥手 Client 向 Server 发送 FIN 包，表示 Client 主动要关闭连接，然后进入 FIN_WAIT_1 状态，等待 Server 返回 ACK 包。此后 Client 不能再向 Server 发送数据，但能读取数据。 Server 收到 FIN 包后向 Client 发送 ACK 包，然后进入 CLOSE_WAIT 状态，此后 Server 不能再读取数据，但可以继续向 Client 发送数据。 Client 收到 Server 返回的 ACK 包后进入 FIN_WAIT_2 状态，等待 Server 发送 FIN 包。 Server 完成数据的发送后，将 FIN 包发送给 Client，然后进入 LAST_ACK 状态，等待 Client 返回 ACK 包，此后 Server 既不能读取数据，也不能发送数据。 Client 收到 FIN 包后向 Server 发送 ACK 包，然后进入 TIME_WAIT 状态，接着等待足够长的时间（2MSL）以确保 Server 接收到 ACK 包，最后回到 CLOSED 状态，释放网络资源。 Server 收到 Client 返回的 ACK 包后便回到 CLOSED 状态，释放网络资源。 4.HTTPS 握手过程 客户端请求服务器，并告诉服务器自身支持的加密算法以及密钥长度等信息 服务器响应公钥和服务器证书 客户端验证证书是否合法，然后生成一个会话密钥，并用服务器的公钥加密密钥，把加密的结果通过请求发送给服务器 服务器使用私钥解密被加密的会话密钥并保存起来，然后使用会话密钥加密消息响应给客户端，表示自己已经准备就绪 客户端使用会话密钥解密消息，知道了服务器已经准备就绪。 后续客户端和服务器使用会话密钥加密信息传递消息 5.HTTPS 握手过程中，客户端如何验证证书的合法性 校验证书的颁发机构是否受客户端信任。 通过 CRL 或 OCSP 的方式校验证书是否被吊销。 对比系统时间，校验证书是否在有效期内。 通过校验对方是否存在证书的私钥，判断证书的网站域名是否与证书颁发的域名一致。 6.Http 状态码 301 和 302 的应用场景分别是什么301 表示永久重定向，302 表示临时重定向。如果浏览器收到的是 301，则会缓存重定向的地址，之后不会再重新请求服务器，直接使用缓存的地址请求，这样可以减少请求次数。但如果浏览器收到的是 302，则不会缓存重定向地址，浏览器将来会继续以原有地址请求。因此，301 适合地址永久转移的场景，比如域名变更；而 302 适合临时转移的场景，比如首页临时跳转到活动页 7.cookie 和 token 都存放在 header 中，为什么不会劫持 token？由于浏览器会自动发送 cookie 到服务器，因此攻击者可以利用这种特点进行 csrf 攻击。而通常 token 是不放到 cookie 中的，需要浏览器端使用 JS 自行保存到 localstorage 中，在请求时也需要手动的加入到请求头中，因此不容易引发 csrf 攻击。 8.token 加密的过程以最常见的 token 格式 jwt 为例, token 分为三段，分别是 header、payload、signature。 其中，header 标识签名算法和令牌类型；payload 标识主体信息，包含令牌过期时间、发布时间、发行者、主体内容等；signature 是使用特定的算法对前面两部分进行加密，得到的加密结果。token 有防篡改的特点，如果攻击者改动了前面两个部分，就会导致和第三部分对应不上，使得 token 失效。而攻击者不知道加密秘钥，因此又无法修改第三部分的值。所以，在秘钥不被泄露的前提下，一个验证通过的 token 是值得被信任的。 9.单点登录SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过 passport，子系统本身将不参与登录操作，当一个系统成功登录以后，passport 将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被 passport 授权以后，会建立一个局部会话，在一定时间内可以无需再次向 passport 发起认证。 具体流程是： 用户访问系统 1 的受保护资源，系统 1 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数 sso 认证中心发现用户未登录，将用户引导至登录页面 用户输入用户名密码提交登录申请 sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，称为全局会话，同时创建授权令牌 sso 认证中心带着令牌跳转会最初的请求地址（系统 1） 系统 1 拿到令牌，去 sso 认证中心校验令牌是否有效 sso 认证中心校验令牌，返回有效，注册系统 1 系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源 用户访问系统 2 的受保护资源 系统 2 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数 sso 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌 系统 2 拿到令牌，去 sso 认证中心校验令牌是否有效 sso 认证中心校验令牌，返回有效，注册系统 2 系统 2 使用该令牌创建与用户的局部会话，返回受保护资源 10.http1.1 是如何复用 tcp 连接的？客户端请求服务器时，通过请求行告诉服务器使用的协议是 http1.1，同时在请求头中附带connection:keep-alive（为保持兼容），告诉服务器这是一个长连接，后续请求可以重复使用这一次的 TCP 连接。这样做的好处是减少了三次握手和四次挥手的次数，一定程度上提升了网络利用率。但由于 http1.1 不支持多路复用，响应顺序必须按照请求顺序抵达客户端，不能真正实现并行传输，因此在 http2.0 出现之前，实际项目中往往把静态资源，比如图片，分发到不同域名下的资源服务器，以便实现真正的并行传输。 11.文件上传如何做断点续传客户端将文件的二进制内容进行分片，每片数据按顺序进行序号标识，上传每片数据时同时附带其序号。服务器接收到每片数据时，将其保存成一个临时文件，并记录每个文件的 hash 和序号。若上传中止，将来再次上传时，可以向服务器索要已上传的分片序号，客户端仅需上传剩余分片即可。当全部分片上传完成后，服务器按照分片的顺序组装成完整的文件，并删除分片文件。 12.介绍 SSL 和 TLS它们都是用于保证传输安全的协议，介于传输层和应用层之间，TLS 是 SSL 的升级版。 它们的基本流程一致： 客户端向服务器端索要公钥，并使用数字证书验证公钥。 客户端使用公钥加密会话密钥，服务端用私钥解密会话密钥，于是得到一个双方都认可的会话密钥 传输的数据使用会话密钥加密，然后再传输，接收消息方使用会话密钥解密得到原始数据 13.网络的五层模型从上到下分别为：应用层、传输层、网络层、数据链路层、物理层。在发送消息时，消息从上到下进行打包，每一层会在上一层基础上加包，而接受消息时，从下到上进行解包，最终得到原始信息。 应用层主要面向互联网中的应用场景，比如网页、邮件、文件中心等等，它的代表协议有 http、smtp、pop3、ftp、DNS 等等 传输层主要面向传输过程，比如 TCP 协议是为了保证可靠的传输，而 UDP 协议则是一种无连接的广播，它们提供了不同的传输方式 网络层主要解决如何定位目标的问题，比如 IP、ICMP、ARP 等等 数据链路层的作用是将数据可靠的传输到目标，比如常见的以太网协议、P2P 协议 物理层是要规范网络两端使用的物理设备，比如蓝牙、wifi、光纤、网线接头等等 14.GET 和 POST 的区别从 http 协议的角度来说，GET 和 POST 它们都只是请求行中的第一个单词，除了语义不同，其实没有本质的区别。 之所以在实际开发中会产生各种区别，主要是因为浏览器的默认行为造成的。 受浏览器的影响，在实际开发中，GET 和 POST 有以下区别： 浏览器在发送 GET 请求时，不会附带请求体 GET 请求的传递信息量有限，适合传递少量数据；POST 请求的传递信息量是没有限制的，适合传输大量数据。 GET 请求只能传递 ASCII 数据，遇到非 ASCII 数据需要进行编码；POST 请求没有限制 大部分 GET 请求传递的数据都附带在 path 参数中，能够通过分享地址完整的重现页面，但同时也暴露了数据，若有敏感数据传递，不应该使用 GET 请求，至少不应该放到 path 中 刷新页面时，若当前的页面是通过 POST 请求得到的，则浏览器会提示用户是否重新提交。若是 GET 请求得到的页面则没有提示。 GET 请求的地址可以被保存为浏览器书签，POST 不可以 15.http 劫持是指攻击者在客户端和服务器之间同时建立了连接通道，通过某种方式，让客户端请求发送到自己的服务器，然后自己就拥有了控制响应内容的能力，从而给客户端展示错误的信息。 16.HTTP 劫持、DNS 劫持与 XSShttp 劫持是指攻击者在客户端和服务器之间同时建立了连接通道，通过某种方式，让客户端请求发送到自己的服务器，然后自己就拥有了控制响应内容的能力，从而给客户端展示错误的信息，比如在页面中加入一些广告内容。DNS 劫持是指攻击者劫持了 DNS 服务器，获得了修改 DNS 解析记录的权限，从而导致客户端请求的域名被解析到了错误的 IP 地址，攻击者通过这种方式窃取用户资料或破坏原有正常服务。XSS 是指跨站脚本攻击。攻击者利用站点的漏洞，在表单提交时，在表单内容中加入一些恶意脚本，当其他正常用户浏览页面，而页面中刚好出现攻击者的恶意脚本时，脚本被执行，从而使得页面遭到破坏，或者用户信息被窃取。要防范 XSS 攻击，需要在服务器端过滤脚本代码，将一些危险的元素和属性去掉或对元素进行HTML实体编码。 17.为什么需要 CA 机构对证书签名主要是为了解决证书的可信问题。如果没有权威机构对证书进行签名，客户端就无法知晓证书是否是伪造的，从而增加了中间人攻击的风险，https 就变得毫无意义。 18.身份验证过程中会涉及到密钥，对称加密，非对称加密，摘要的概念秘钥密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。 对称加密对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有 DES、3DES、TDEA、Blowfish、RC5 和 IDEA。 非对称加密非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。 摘要摘要算法又称哈希&#x2F;散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串 18.webSocket 协议是什么websocket 协议 HTML5 带来的新协议，相对于 http，它是一个持久连接的协议，它利用 http 协议完成握手，然后通过 TCP 连接通道发送消息，使用 websocket 协议可以实现服务器主动推送消息。首先，客户端若要发起 websocket 连接，首先必须向服务器发送 http 请求以完成握手，请求行中的 path 需要使用ws:开头的地址，请求头中要分别加入upgrade、connection、Sec-WebSocket-Key、Sec-WebSocket-Version标记然后，服务器收到请求后，发现这是一个 websocket 协议的握手请求，于是响应行中包含Switching Protocols，同时响应头中包含upgrade、connection、Sec-WebSocket-Accept标记当客户端收到响应后即可完成握手，随后使用建立的 TCP 连接直接发送和接收消息。 19.webSocket 与传统的 http 有什么优势当页面中需要观察实时数据的变化（比如聊天、k 线图）时，过去我们往往使用两种方式完成:第一种是短轮询，即客户端每隔一段时间就向服务器发送消息，询问有没有新的数据第二种是长轮询，发起一次请求询问服务器，服务器可以将该请求挂起，等到有新消息时再进行响应。响应后，客户端立即又发起一次请求，重复整个流程。无论是哪一种方式，都暴露了 http 协议的弱点，即响应必须在请求之后发生，服务器是被动的，无法主动推送消息。而让客户端不断的发起请求又白白的占用了资源。websocket 的出现就是为了解决这个问题，它利用 http 协议完成握手之后，就可以与服务器建立持久的连接，服务器可以在任何需要的时候，主动推送消息给客户端，这样占用的资源最少，同时实时性也最高。 20.如何劫持 https 的请求https 有防篡改的特点，只要浏览器证书验证过程是正确的，很难在用户不察觉的情况下进行攻击。但若能够更改浏览器的证书验证过程，便有机会实现 https 中间人攻击。所以，要劫持 https，首先要伪造一个证书，并且要想办法让用户信任这个证书，可以有多种方式，比如病毒、恶意软件、诱导等。一旦证书被信任后，就可以利用普通中间人攻击的方式，使用伪造的证书进行攻击。 21.怎样解决跨域问题 使用 JSONP这是一种古老的解决跨域问题的思路。在需要跨域请求时，事先准备好一个处理服务器数据的函数，然后生成一个script元素，src指向跨域站点，同时把准备好的函数名通过地址参数传递到服务器。跨域站点返回一段调用该函数的脚本，当客户端接收到脚本后就会运行事先准备的函数，从而实现跨域获取数据。JSONP 实现简单、兼容性好，但缺点也很明显，它只支持 get 请求，同时也有安全性问题，并且对服务器端代码侵入性比较强。 使用 cors在请求时，客户端使用一些特殊的请求头向服务器申请跨域访问，并通过这些请求头告诉服务器自己的行为。服务器根据自身的规则决定是否允许跨域，如果允许，则通过响应头告诉客户端可以发送跨域请求。cors 协议已被各种主流浏览器支持，它安全性高，同时也不会侵入服务器代码，是目前最主流的跨域方式除此之外，远古时期的跨域处理还包括 iframe、form 等，由于它们缺陷非常明显，故很少使用了。 22. HTTP 常用状态码 301 302 304 403 301 永久重定向，浏览器会把重定向后的地址缓存起来，将来用户再次访问原始地址时，直接引导用户访问新地址 302 临时重定向，浏览器会引导用户进入新地址，但不会缓存原始地址，下一次用户访问源地址时，浏览器仍然要请求原地址的服务器 304 资源未修改，服务器通过该状态码告诉客户端，请求的资源和过去一样，并没有任何变化，建议自行使用过去的缓存。通常，304 状态码的响应中，服务器不会附带任何的响应体。 403 不允许访问。服务器通过该状态码告诉客户端，这个资源目前不允许访问。这种状态码通常出现在权限不足的情况下。 22.在浏览器地址栏输入地址，并按下回车键后，发生了哪些事情？ 浏览器自动补全协议、端口 浏览器自动完成url编码 浏览器根据url地址查找本地缓存，根据缓存规则看是否命中缓存，若命中缓存则直接使用缓存，不再发出请求 通过DNS解析找到服务器的IP地址 浏览器向服务器发出建立TCP连接的申请，完成三次握手后，连接通道建立 若使用了HTTPS协议，则还会进行SSL握手，建立加密信道。使用SSL握手时，会确定是否使用HTTP2 浏览器决定要附带哪些cookie到请求头中 浏览器自动设置好请求头、协议版本、cookie，发出GET请求 服务器处理请求，进入后端处理流程。完成处理后，服务器响应一个HTTP报文给浏览器 浏览器根据使用的协议版本，以及Connection字段的约定，决定是否要保留TCP连接。 浏览器根据响应状态码决定如何处理这一次响应 浏览器根据响应头中的Content-Type字段识别响应类型，如果是text&#x2F;html，则对响应体的内容进行HTML解析，否则做其他处理 浏览器根据响应头的其他内容完成缓存、cookie的设置 浏览器开始从上到下解析HTML，若遇到外部资源链接，则进一步请求资源 解析过程中生成DOM树、CSSOM树，然后一边生成，一边把二者合并为渲染树（rendering tree），随后对渲染树中的每个节点计算位置和大小（reflow），最后把每个节点利用GPU绘制到屏幕（repaint） 在解析过程中还会触发一系列的事件，当DOM树完成后会触发DOMContentLoaded事件，当所有资源加载完毕后会触发load事件 23.cookie&#x2F;sessionStorage&#x2F;localStorage 的区别cookie、sessionStorage、localStorage 都是保存本地数据的方式其中，cookie 兼容性较好，所有浏览器均支持。浏览器针对 cookie 会有一些默认行为，比如当响应头中出现set-cookie字段时，浏览器会自动保存 cookie 的值；再比如，浏览器发送请求时，会附带匹配的 cookie 到请求头中。这些默认行为，使得 cookie 长期以来担任着维持登录状态的责任。与此同时，也正是因为浏览器的默认行为，给了恶意攻击者可乘之机，CSRF 攻击就是一个典型的利用 cookie 的攻击方式。虽然 cookie 不断的改进，但前端仍然需要另一种更加安全的保存数据的方式。HTML5 新增了 sessionStorage 和 localStorage，前者用于保存会话级别的数据，后者用于更持久的保存数据。浏览器针对它们没有任何默认行为，这样一来，就把保存数据、读取数据的工作交给了前端开发者，这就让恶意攻击者难以针对登录状态进行攻击。cookie 的大小是有限制的，一般浏览器会限制同一个域下的 cookie 总量为 4M，而 sessionStorage 和 localStorage 则没有限制cookie 会与 domain、path 关联，而 sessionStorage 和 localStorage 只与 domain 关联 24.http1.0、http2.0、http3.0 之间的区别 http1.0每次请求和响应完毕后都会销毁 TCP 连接，同时规定前一个响应完成后才能发送下一个请求。这样做有两个问题： 无法复用连接每次请求都要创建新的 TCP 连接，完成三次握手和四次挥手，网络利用率低 队头阻塞如果前一个请求被某种原因阻塞了，会导致后续请求无法发送。 http2.0http2.0 优化了传输效率，它主要有以下改进： 二进制分帧将传输的消息分为更小的二进制帧，每帧有自己的标识序号，即便被随意打乱也能在另一端正确组装 多路复用 基于二进制分帧，在同一域名下所有访问都是从同一个 tcp 连接中走，并且不再有队头阻塞问题，也无须遵守响应顺序 头部压缩 http2.0 通过字典的形式，将头部中的常见信息替换为更少的字符，极大的减少了头部的数据量，从而实现更小的传输量4. 服务器推 http2.0 允许服务器直接推送消息给客户端，无须客户端明确的请求 http3.0 http3.0 它完全抛弃了 TCP 协议，转而使用 UDP 协议，是为了进一步提升性能。 虽然 http2.0 进行了大量的优化，但它无法摆脱 TCP 协议本身的问题，比如建立连接时间长、对头阻塞问题等等。为了保证传输的可靠性，http3.0 使用了 QUIC 协议。 25.post 请求什么时候用 form data 什么时候用 request payloadform data 适合传递简单的键值对信息，由于传递的信息比较扁平，难以传递深层次嵌套的数据request payload 适合传递任意格式的数据，包括单个数字、布尔、深层次嵌套的对象、数组等，但 request payload 不适合传递文件数据在前后端分离的项目中，对于非文件数据的传递，都推荐使用 request payload 的形式，以传递最明确的数据类型和数据结构，而对于文件上传，则推荐使用传统的 form data 26.http 常见请求方法有哪些 GET，表示向服务器获取资源 POST，表示向服务器提交信息，通常用于产生新的数据，比如注册 PUT，表示希望修改服务器的数据，通常用于修改 DELETE，表示希望删除服务器的数据 OPTIONS，发生在跨域的预检请求中，表示客户端向服务器申请跨域提交 TRACE，回显服务器收到的请求，主要用于测试和诊断 CONNECT，用于建立连接管道，通常在代理场景中使用，网页中很少用到 27.列举优化网络性能方法 优化打包体积 利用一些工具压缩、混淆最终打包代码，减少包体积 多目标打包 利用一些打包插件，针对不同的浏览器打包出不同的兼容性版本，这样一来，每个版本中的兼容性代码就会大大减少，从而减少包体积 压缩 现代浏览器普遍支持压缩格式，因此服务端的各种文件可以压缩后再响应给客户端，只要解压时间小于优化的传输时间，压缩就是可行的 CDN 利用 CDN 可以大幅缩减静态资源的访问时间，特别是对于公共库的访问，可以使用知名的 CDN 资源，这样可以实现跨越站点的缓存 缓存 对于除 HTML 外的所有静态资源均可以开启协商缓存，利用构建工具打包产生的文件 hash 值来置换缓存 http2 开启 http2 后，利用其多路复用、头部压缩等特点，充分利用带宽传递大量的文件数据 雪碧图 对于不使用 HTTP2 的场景，可以将多个图片合并为雪碧图，以达到减少文件的目的 defer、async 通过 defer 和 async 属性，可以让页面尽早加载 js 文件 prefetch、preload 通过 prefetch 属性，可以让页面在空闲时预先下载其他页面可能要用到的资源通过 preload 属性，可以让页面预先下载本页面可能要用到的资源 多个静态资源域 对于不使用 HTTP2 的场景，将相对独立的静态资源分到多个域中保存，可以让浏览器同时开启多个 TCP 连接，并行下载 28.session 怎么消除 过期时间当客户端长时间没有传递 sessionid 过来时，服务器可以在过期时间之后自动清除 session 客户端主动通知可以使用 JS 监听客户端页面关闭或其他退出操作，然后通知服务器清除 session 29.什么是 DNS 域名解析DNS 域名解析是指把域名解析成 IP 地址的过程。在具体的实现上，域名解析是由多个层级的服务器共同完成的。在查询域名时，客户端会先检查自身的 DNS 映射表，若找不到解析记录，则使用用户配置的 DNS 服务器，若目标 DNS 服务器中找不到记录，则继续往上一个层级寻找，直到到达根域名服务器，根域名服务器会根据域名的类型，将解析任务分发到对应的子域名服务器依次查找，直到找到解析记录为止。"},{"title":"vscode中settings配置","date":"2023-03-23T14:55:33.000Z","url":"/posts/849a3ae4.html","categories":[["通用","/categories/%E9%80%9A%E7%94%A8/"]],"content":"vsCode中setting基本配置项目中总结出来的一些相关配置 "},{"title":"react常用hooks","date":"2023-03-23T14:53:59.000Z","url":"/posts/8ae780ab.html","categories":[["react","/categories/react/"]],"content":"useOnce类似于componentDidMount 使用方法 EventBus事件的发布订阅 使用方法 useSearchParams获取地址栏参数(all) 使用 useModal 使用"},{"title":"react基础","date":"2023-03-23T14:52:31.000Z","url":"/posts/b172fb3f.html","tags":[["面试题系列","/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B3%BB%E5%88%97/"]],"categories":[["面试题","/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"]],"content":"组件基础1、react事件绑定原理 react 并不是将click事件绑定到了div真实的DOM上，而是在document处监听了所有的事件，当事件发生并且冒泡到document处的时候，react 将事件内容封装并交由真正的处理函数执行。这样的方式不仅仅减少了内存的消耗，还能在组件挂载销毁时统一订阅和移除事件。 还有， 冒泡到document上的事件也不是原生的浏览器事件，而是由react自己合成的事件，所以不想要事件冒泡的话应该调用event.preventDefault()方法，而不是调用event.stopProppagation()方法 2、React的事件和普通的HTML事件有什么不同？区别： 对于事件名称的命名方式，原生事件为全小写，而react 事件采用小驼峰 对于事件函数处理语法，原生事件为字符串，react 事件为函数 react 事件不能采取return false的方法来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为 合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象 优点 兼容所有的浏览器，更好的跨平台 将事件统一存放在一个数组，避免频繁的新增和删除（垃圾回收） 方便react统一管理和事件机制 3、 React 组件中怎么做事件代理？它的原理是什么？react基于Virtual DOM实现一个事件合成层，定义的事件处理器会接收到一个合成事件对象的实例。它符合W3CW标准，且与原生浏览器事件有相同的接口。支持冒泡事件，所有的事件都自动绑定在最外层。 在React底层，主要对合成事件做了：事件委派和自动绑定。 事件委派： react会把所有事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上w维持了一个映射来保存s所有组件内部事件监听和处理函数 自动绑定： react组件中，每个方法的上下文都对指向该组件的实例，即自动绑定 this 为当前组件 4、React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代这三个是目前react解决代码复用的主要方式。 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。 render props是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术，更具体的说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。 通常，render props 和高阶组件只渲染一个子节点。让 Hook 来服务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个虚拟滚动条组件或许会有一个 renderltem 属性，或是一个可见的容器组件或许会有它自己的 DOM 结构）。但在大部分场景下，Hook 足够了，并且能够帮助减少嵌套。 HOC 官方解释∶ 简单的来说，HOC是一种组件的设计模式，HOC接受一个组件和额外的参数（如果需要），返回一个新的组件。HOC 是纯函数，没有副作用。 hoc的优缺点∶ 优点∶ 逻辑服用、不影响被包裹组件的内部逻辑 缺点：hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖 Render props 官方解释∶ 具有render prop 的组件接受一个返回 react 元素的函数，将render的渲染逻辑注入到组件内部，在这里 render 的命名可以使其他有效的标识符 jsx 由此可以看到，render props的优缺点也很明显∶ 优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。 缺点：无法在 return 语句外访问数据、嵌套写法不够优雅 Hooks 官方解释∶ jsx 以上可以看出，hook解决了hoc的prop覆盖的问题，同时使用的方式解决了render props的嵌套地狱的问题。hook的优点如下∶ 使用直观 解决hoc的prop 重名问题 解决render props 因共享数据 而出现嵌套地狱的问题 能在return之外使用数据的问题 需要注意的是∶hook只能在组件顶层使用，不可在分支语句中使用。 总结： Hoc、render props和hook都是为了解决代码复用的问题，但是hoc和render props都有特定的使用场景和明显的缺点。hook是react16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点。 5、对React-Fiber的理解，它解决了什么问题？React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们， 一气呵成。这个过程期间， React 会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，导致用户感觉到卡顿 为了给用户制造一种应用很快的“假象”，不能让一个任务长期霸占着资源。 可以将浏览器的渲染、布局、绘制、资源加载(例如 HTML 解析)、事件响应、脚本执行视作操作系统的“进程”，需要通过某些调度策略合理地分配 CPU 资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。 所以 React 通过Fiber 架构，让这个执行过程变成可被中断。“适时”地让出 CPU 执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处: 分批延时对DOM进行操作，避免一次性操作大量 DOM 节点，可以得到更好的用户体验； 给浏览器一点喘息的机会，它会对代码进行编译优化（JIT）及进行热代码优化，或者对 reflow 进行修正。__核心思想：__Fiber 也称协程、或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。 6、React.Component 和 React.PureComponent 的区别？pureComponent表示一个纯组件，可以用来优化react组件，减少render函数执行的次数，从而提高组件的性能 在react中，当props或state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。 不过，pureComponent中的shouldComponentUpdate()进行的是 浅比较 ，也就是说如果是 引用类型数据 ,只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性或状态突变情况。其实也就是数据引用指针没有变化。而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。 使用pureComponent的好处：当组件更新时，如果组件的props或state没有改变，render函数就不会触发。省去虚拟dom的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。 7、Component, Element, Instance 之间有什么区别和联系？元素: 一个元素element是一个普通对象，描述了对于一个DOM节点或者其他组件component,你想让他在屏幕中呈现什么样子。素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。 组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。 实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。 函数试组件根本没有instance实例，类组件有实例，但是永远也不要直接创建一个组件的实例，因为react已经帮我们做了这些。 8、对componentWillReceiveProps 的理解该生命周期函数只有在props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取，这里调用更新状态是安全的。并不会触发额外的render调用。 使用好处： 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。componentWillReceiveProps(nextProps)在初始化render的时候不会执行，它会在component接收到新的props（状态）时被触发，一遍用于父组件状态更新时子组件重新渲染。 9、哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？1、哪些方法会触发 react 重新渲染? setState()方法被调用 setState是react中最常用的命令，通常情况下，执行setState会触发render。但是这里有个点需要注意一下，执行setState的时候一定会重新渲染吗？答案是不一定，当setState传入null的时候，并不会触发render。 父组件重新渲染只有父组件重新渲染了，即使传入子组件的props未发生变化，那么子组件也会重新渲染，进而触发render 2、重新渲染render会做些什么？ 会对新旧Vnode进行对比，也就是我们所说的diff算法 对新旧两颗树进行一个深度优先遍历，这样每一个节点都会有一个标记，在到深度遍历的时候，每遍历到一个节点。就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面 遍历差异对象，根据差异的类型，根据应对规则更新Vnode react的处理Render的基本思维模式是每次一有变动就会去重新渲染整个应用。在虚拟dom没出现之前，最简单的方法就是直接调用innerHTML。虚拟dom厉害的地方并不是说他比直接操作dom快，而是说不管数据怎么变，都会尽量以最小的代价去更新dom，react将render函数返回的虚拟dom树与老的进行比较，从而确定dom要不要更新、怎么更新。当DOM树很大时，遍历两棵树进行各种比对是相当耗性能的，特别是在顶层setState一个微小的修改，默认回去遍历整颗树。尽管react使用高度优化的diff算法，但是这个过程仍会损耗性能。 10、React如何判断什么时候重新渲染组件？组件状态的改变可以因为props的改变，或者直接通过setState方法改变。组件获得新的状态然后React决定是否应该重新渲染组件。只要组件的State发生变化，react就会对组件进行重新渲染。这是因为react中的shouldComponentUpdate方法默认返回 true，这就是导致每次更新都重新渲染的原因。 当react将要渲染组件时会执行shouldComponentUpdate方法来看它是否返回true（组件应该更新，也就是重新渲染）。所以需要重写shouldComponentUpdate方法让它根据情况返回true或者false来告诉React什么时候重新渲染什么时候跳过重新渲染。 11、对有状态组件和无状态组件的理解及使用场景有状态组件 特点： 是一个类组件、有继承、可以使用this 可以使用react的生命周期 使用较多，容易频繁触发生命周期钩子函数，影响性能 内部使用state,维护自身状态的变化，有状态组件根据外部组件传入的props和自身的State进行渲染 使用场景 需要使用到状态的 需要使用状态操作组件的（无状态组件的也可以实现新版本react hooks也可以实现） 总结：类组件可以维护自身的状态变量，即组件的state,类组件还有不同的生命周期方法，可以让开发者能够在组件的不同阶段（挂载、更新、卸载），对组件做更多的控制。类组件既可以充当无状态组件，也可以充当有状态组件。当一个类组件不需要管理自身状态时，也可以被称为无状态组件。 无状态组件 特点 不依赖自身的状态state 可以使类组件或者函数组件 可以完全避免使用this关键字（由于使用的是箭头函数无需绑定） 有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态组件 组件内部不维护state，只根据外部组件传入的props进行渲染的组件，当props改变时，组件重新渲染 使用场景 组件不需要管理state，纯展示 有点 简化代码，专注render 组件不需要被实例化，无生命周期，提高性能。渲染只取决于属性，无副作用 视图和数据的解耦分离 缺点 无法使用ref和生命周期方法 无法控制组件的重渲染，因为无法使用shouldComponentUpdate方法，当组件接收到的属性时则会冲渲染 总结：组件内部状态且与外部无关的组件，可以考虑用五状态组件，这样状态数就不会过于复杂，易于理解和管理。当一个组件不需要管理自身状态时，也就是无状态组件，应该优先设计为函数组件。 12、对React中Fragment的理解，它的使用场景是什么？在react中，组件返回的元素只能有一个根元素。为了不添加多余的dom节点，我们可以使用Fragment标签来包裹所有的元素，Fragment标签不会渲染出任何元素。 13、在React中如何避免不必要的render？React基于虚拟DOM和高效diff算法的完美配合，实现了对DOM最小粒度的更新。大多情况下，react对DOM的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然存在。此时需要采取一些措施来提升运行性能，其很重要的一个方向就是尽可能的避免render shouldComponentUpdate和PureComponent 在react类组件中，可以利用shouldComponentUpdate或者pureComponent来减少因父组件更新而触发子组件render，从而达到目的。shouldComponentUpdate来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回false即可。 利用高阶组件 在函数组件中，并没有 shouldComponentUpdate这个生命周期，可以利用高阶组件，封装一个类似PureComponet的功能 使用React.memo React.mome是react16.0新的一个API，用来缓存组件的渲染，避免不必要的更新，其实也会死你一个高阶组件，与PureComponent十分类似，但不同的是React.memo只能用于函数组件。 14、对 React context 的理解在React中， 数据传递一般使用props传递数据，维持单项数据流，这样可以让组件之间的关系变得简单可预测，但是单向数据流在某些场景中并不适用。单纯一对的父子组件传递并无问题，但要是组件之间层层依赖深入，props就需要层层传递，显然这样做太繁琐了。 Context提供了一种在组件之间共享此类值得方法，而不必显式的通过组件树的逐层传递 props 可以把context当做是特定一个组件数内共享的store，用来做数据传递。简单的说就是，当年你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。 js的代码在执行期间，会创建一个相应的作用域链，这个作用域链记录这运行时js代码块执行期间所能访问的活动对象，包括变量和函数，js程序通过作用域链访问到代码块内部或者外部的变量和函数 假如以js的作用域链作为类比，react组件提供的context对象其实就是好比一个提供给子组件访问的作用域，而Context对象的属性可以看成作用域上的活动对象。由于组件的context由父节点链上所有组件通过getChildContext（）返回的context对象组合而成，所以组件通过context是可以访问到其父组件链上所有节点组件提供的context的属性。 15、为什么React并不推荐优先考虑使用Context？ context目前还处于实验阶段，可能会在后面发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来的影响和麻烦，不建议在app中使用context。 尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context； 对于组件之间的数据通信或者状态管理，有效使用props或者State解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳方案的时候，考虑context context的更新需要通过setState()触发，但是这并不是可靠的，context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如shouldComponentUpdate() 返回false那么不能保证context的更新一定可以使用context的子组件，因此，context的可靠性需要关注 16、React中refs的作用是什么？有哪些应用场景？Refs提供了一种方式，用于访问在 render方法中创建的react元素或DOM节点，refs应该谨慎使用，如下场景使用refs比较适合： 处理焦点、文本选择或者媒体的控制 触发必要的动画 集成第三方DOM库 注意： 不应该国度的使用refs ref的返回值取决于节点的类型 当ref属性被用于一个普通的HTML元素时，react.createRef()将接收底层DOM元素作为它的current属性以创建ref。 当ref属性被用于一个自定义的类组件时，ref对象将接收该组件已挂载的实例作为它的current 当在父组件中需要访问子组件中的ref时可使用传递refs或回调refs。 17、React组件的构造函数有什么作用？它是必须的吗？构造函数主要用于两个目的： 通过将对象分配给this.state来初始化本地状态 将事件处理程序方法绑定到实例上 所以，当在React class中需要设置state的初始值或者绑定事件时，需要加上构造函数，官方Demo: 构造函数用来新建父类的this对象；子类必须在constructor方法中调用super方法；否则新建实例时会报错；因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法；子类就得不到this对象。 注意： constructor() 必须配上super()，如果要在constructor内部使用this.props就要传入props，否则不用 js中的bind每次都会返回一个新的函数，为了性能等考虑，尽量在constructor中绑定事件 "},{"title":"H5常见机型适配","date":"2023-03-23T14:51:02.000Z","url":"/posts/47cf154e.html","categories":[["通用","/categories/%E9%80%9A%E7%94%A8/"]],"content":""},{"title":"工具函数","date":"2023-03-23T14:50:18.000Z","url":"/posts/6085e14f.html","categories":[["通用","/categories/%E9%80%9A%E7%94%A8/"]],"content":"localStorage的已使用空间在较新的chrome上测试，localStorage的存储是按照字符个数来算的。 包含键和值的。所以在测试代码中，你把a修改啊，不会影响存储的数量。 但是键的长度，会影响存储的数量。 示例 带图带事件的桌面通知 示例 原生30行代码实现视频截图基本原理就是把视频画到Canvas里面，然后调用toDataURL或者toBlob，再利用a标签模拟点击，download属性指定名字。 示例注意添加crossorigin=&quot;anonymous&quot;，不然转为图片会失败。 基于URLSearchParams或URL获取queryString的值常用的方式是使用正则或者split方法，其实不然，URLSearchParams和URL都能很好的实现功能。 示例 基于atob和btoa的base64编码和解码浏览器内置了base64编码和解码的能力，第三方库，不需要的。 示例 非正则替换的html代码encode和decode常规的方式是使用正则替换，这里是另外一种思路。 示例 相对地址转换为绝对地址 示例 基于URL或者Crypto.getRandomValues生成UUIDURL.createObjectURL 产生的地址为 blob:, 其后部分就是一个UUID 方法一 方法二 基于Array.from的序列生成器造有序数据，无序数据，等等。 示例 基于sendBeacon的安全的数据上报 示例 基于toLocaleString千分位正则？ 遍历？ 不需要的。内置函数就解决。当然，如果是超大的数，可能是会有问题的。 示例 Promise顺序执行让Promise顺序的执行，并支持初始化参数和结果作为参数传递。 示例 延时执行delay延时执行某函数，且只会执行一次。 示例 进度值映射进度映射，比较只有 10%的进度，确要显示50%的进度的场景。 示例 滑滚动页面到顶部PC端滚动的根元素是document.documentElement,移动端滚动的的根元素是document.body,有一个更好的属性document.scrollingElement能自己识别文档的滚动元素， 其在PC端等于document.documentElement, 其在移动端等于document.body 禁止选择和复制 CSS 禁止图片拖拽 自增长ID自己生产自增长的ID值，当然可以更复杂一些。 示例 "},{"title":"js常用方法","date":"2023-03-23T14:47:54.000Z","url":"/posts/11be3759.html","categories":[["通用","/categories/%E9%80%9A%E7%94%A8/"]],"content":"去除空格 防抖函数 跳转函数 字符串首字母变大写 日期格式化 填0函数 设置cookie uncode解码 加密&amp;&amp;解密 获取search中的数据 检测浏览器window.search是否有指定字段 延迟函数delay 分割指定长度的元素数组 获取数组交集 函数柯里化 字符串前面空格去除与替换 字符串后面空格去除与替换 获取当前子元素是其父元素下子元素的排位 获取当前元素相对于document的偏移量 获取元素类型 判断是否是移动端 fade动画 将指定格式的字符串解析为日期字符串 禁止网页复制粘贴 input框限制只能输入中文 去除字符串中的html代码 mac安装brew"},{"title":"js篇","date":"2023-03-23T14:46:44.000Z","url":"/posts/17c7b154.html","tags":[["面试题系列","/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B3%BB%E5%88%97/"]],"categories":[["面试题","/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"]],"content":"js中的事件循环机制进程、线程 进程是系统分配的独立资源，是CPU资源分配的基本单位，进程是由一个或者多个线程组成的。 线程是进程的执行流，是CPU调度和分派的基本单位，同个进程之中的多个线程之间是共享该进程资源的。 浏览器内核 浏览器内核有多种线程在工作 GUI渲染线程负责渲染页面，解析 HTML，CSS 构成 DOM 树等，当页面重绘或者由于某种操作引起回流都会调起该线程和 JS 引擎线程是互斥的，当 JS 引擎线程在工作的时候，GUI 渲染线程会被挂起，GUI 更新被放入在 JS 任务队列中，等待 JS 引擎线程空闲的时候继续执行。 JS 引擎线程单线程工作，负责解析运行 JavaScript 脚本。和 GUI 渲染线程互斥，JS 运行耗时过长就会导致页面阻塞。 事件触发线程:当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到任务队列的队尾，等待 JS 引擎处理。 定时器触发线程浏览器定时计数器并不是由 JS 引擎计数的，阻塞会导致计时不准确。开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待 JS 引擎处理。 http 请求线程http 请求的时候会开启一条请求线程。请求完成有结果了之后，将请求的回调函数添加到任务队列中，等待 JS 引擎处理。 JavaScript 引擎是单线程JavaScript 引擎是单线程，也就是说每次只能执行一项任务，其他任务都得按照顺序排队等待被执行，只有当前的任务执行完成之后才会往下执行下一个任务。HTML5 中提出了 Web-Worker API，主要是为了解决页面阻塞问题，但是并没有改变 JavaScript 是单线程的本质 JavaScript 事件循环机制JavaScript 事件循环机制分为浏览器和 Node 事件循环机制，两者的实现技术不一样，浏览器 Event Loop 是 HTML 中定义的规范，Node Event Loop 是由 libuv 库实现。这里主要讲的是浏览器部分。 Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。 JS 调用栈JS 调用栈是一种后进先出的数据结构。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。 同步任务、异步任务JavaScript 单线程中的任务分为同步任务和异步任务。同步任务会在调用栈中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。 Event Loop调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环。 定时器定时器会开启一条定时器触发线程来触发计时，定时器会在等待了指定的时间后将事件放入到任务队列中等待读取到主线程执行。 定时器指定的延时毫秒数其实并不准确，因为定时器只是在到了指定的时间时将事件放入到任务队列中，必须要等到同步的任务和现有的任务队列中的事件全部执行完成之后，才会去读取定时器的事件到主线程执行，中间可能会存在耗时比较久的任务，那么就不可能保证在指定的时间执行。 宏任务(macro-task)、微任务(micro-task)除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。 macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。 micro-task包括：process.nextTick, Promises, Object.observe, MutationObserver。 示例中，setTimeout 和 Promise被称为任务源，来自不同的任务源注册的回调函数会被放入到不同的任务队列中。 有了宏任务和微任务的概念后，那 JS 的执行顺序是怎样的？是宏任务先还是微任务先？ 第一次事件循环中，JavaScript 引擎会把整个 script 代码当成一个宏任务执行，执行完成之后，再检测本次循环中是否寻在微任务，存在的话就依次从微任务的任务队列中读取执行完所有的微任务，再读取宏任务的任务队列中的任务执行，再执行所有的微任务，如此循环。JS 的执行顺序就是每次事件循环中的宏任务-微任务。 上面的示例中，第一次事件循环，整段代码作为宏任务进入主线程执行。遇到了 setTimeout ，就会等到过了指定的时间后将回调函数放入到宏任务的任务队列中。遇到 Promise，将 then 函数放入到微任务的任务队列中。整个事件循环完成之后，会去检测微任务的任务队列中是否存在任务，存在就执行。第一次的循环结果打印为: 1,3,5,4。接着再到宏任务的任务队列中按顺序取出一个宏任务到栈中让主线程执行，那么在这次循环中的宏任务就是 setTimeout 注册的回调函数，执行完这个回调函数，发现在这次循环中并不存在微任务，就准备进行下一次事件循环。检测到宏任务队列中已经没有了要执行的任务，那么就结束事件循环。最终的结果就是 1,3,5,4,2。 js中微任务和宏任务的区别 宏任务：当前调用栈中执行的代码成为宏任务。（主代码快，定时器等等）。 微任务： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务,可以理解为回调事件。（promise.then，proness.nextTick等等）。 宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。 运行机制 在执行栈中执行一个宏任务。 执行过程中遇到微任务，将微任务添加到微任务队列中。 当前宏任务执行完毕，立即执行微任务队列中的任务。 当前微任务队列中的任务执行完毕，检查渲染，GUI线程接管渲染。 渲染完毕后，js线程接管，开启下一次事件循环，执行下一次宏任务（事件队列中取）。 微任务：process.nextTick、MutationObserver、Promise.then catch finally 宏任务：I&#x2F;O、setTimeout、setInterval、setImmediate、requestAnimationFrame"},{"title":"lerna搭建脚手架遇到的问题记录","date":"2023-03-23T14:44:57.000Z","url":"/posts/d1b186b.html","categories":[["问题记录","/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"]],"content":"前言使用lerna搭建了一个脚手架，打算发布到npm上去，记录一下遇到的问题 npm登录登录过程 这些输入之后一直处于一个登录状态，登录好长时间发现返回了一个Error: 500 Internal Server Error - PUT  因为之前一直用的是淘宝的源，所以想着是不是因为源的问题导致的 这里使用的是nrm没装这个的话自己去装一下 查看之后发现我之前直接设置的是淘宝源没有设置npm的源 这样npm源就设置好了然后，我们再次执行npm login 返回 证明就执行成功了！ 接下来就使用lerna发布npm 提示我package.json中存在淘宝源 导致报错 然后去lerna官网去查询发现只需要将 就可以了执行lerna publish然后就发布成功了！"},{"title":"http","date":"2023-03-23T14:43:32.000Z","url":"/posts/97780db2.html","tags":[["面试题系列","/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B3%BB%E5%88%97/"]],"categories":[["面试题","/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"]],"content":"http和https1.http和https基本概念http: 是一个客户端和服务器端请求和应答标准（TCP），用于从www服务器传输超文本到本地浏览器的超本文传输协议。 https: 是安全为目标的http通道，即http下加入SSL层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。 2.http和https区别及优缺点 http是超文本传输协议，信息是明文传输，https协议比http协议安全，https是具有安全性的ssl加密传输协议，可防止数据在传输过程中被窃取、改变。确保数据的完整性 http协议的默认端口是80，https的默认端口是443 http的链接很简单，是无状态的。https的握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电 https的缓存不如http高效，会增加数据开销 https需要ca证书，费用较高，功能越强大的证书费用越高 SSL证书需要绑定IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。 3.https 协议的工作原理 客户端在使用https方式与web服务器通信时有以下几个步骤： 客户端使用https url访问服务器，则要求web服务器建立ssl链接 web服务器在接收到客户端的请求后，会将网站证书（证书中包含公钥）传输给客户端 客户端和web服务器端开始协商ssl链接的安全等级,也就是加密等级 客户端浏览器通过上访协商一致的安全等级，建立会话秘钥，然后通过网站的公钥来加密会话秘钥，并传送给网站 web服务器通过自己的私钥解密出会话秘钥 web服务器通过会话秘钥加密客户端之间的通信 "},{"title":"函数式编程范式","date":"2023-03-23T14:42:29.000Z","url":"/posts/42f6abb3.html","categories":[["js基础","/categories/js%E5%9F%BA%E7%A1%80/"]],"content":"高阶函数 可以把函数作为参数传递给另一个函数 可以把函数作为另一个函数的返回结果 函数作为返回值 常用的高阶函数高阶函数的意义 抽象可以帮屏蔽细节，只需要关注与我们的目标 高阶函数是用来抽象通用的问题 filter forEach map every some 闭包 函数和其周围的状态（词法环境）引用捆绑在一起形成闭包 可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员 闭包的本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员，因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员。 纯函数概念 纯函数：相同的输入永远会得到相同的输出，而且没有任何可观察的副作用 纯函数就类似数学中的函数，y&#x3D;f(x); 数组中的slice和splice，分别是纯函数和不纯的函数 splice返回数组中指定的部分，不会改变原数组 splice对数组进行操作返回该数组，会改变原数组 自定义纯函数 函数式编程不会保留计算结果，所以变量是不可变的（无状态的） 我们可以把一个函数的执行结果交给另一个函数去处理 纯函数的优势 可缓存 可测试 并行处理 在多线程环境下并行操作共享的内存数据很可能会出现意外情况 纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数 副作用 副作用让一个函数变得不纯，纯函数是根据相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用。 所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降不适合扩展和可重用性，同时副作用也会带来安全隐患，给程序带来不确定性，但是副作用不可能完全禁止，尽可能控制它们在可控范围内发剩。 3.柯里化 当一个函数有多个参数的时候先传递一部分参数（这部分参数以后永远不变） 然后返回一个新的函数接收剩余的参数，返回结果 4.PointFree我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只需要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数 不需要指明处理的数据 只需要合成运算过程 需要定义一些辅助的基运算函数 5.Functor (函子) 容器：包含值和值得变形关系（这个变形关系就是函数） 函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有 map 方法，map方法可以运行一个函数对值进行处理（变形关系） 总结 函数式编程的运算不直接操作值，而是由函子完成 函子就是一个实现了 map 契约的对象 我们可以把函子想象成一个盒子，这个盒子里封装了一个值 想要处理盒子中的值，我们需要给盒子的map方法传递一个处理值得函数（纯函数），由这个函数对值进行处理 最终map方法返回一个包含新值的盒子（函子） 5.MayBe (函子)MayBe函子的作用就是可以对外部的空值做处理（控制副作用在允许的范围） 6.Either (函子) 两者中的任何一个，类似于if...else的处理 异常会让函数变得不纯，Either函子可以用来做异常处理 7.IO函子 IO函子中 的_value是一个函数，这里是把函数作为值来处理 IO函子可以把不纯的动作存储到_value中，延迟执行这个不纯的操作（惰性执行），包装当前的操作纯 把不纯的操作交给调用者来处理 Task异步执行 异步任务的实现过于复杂，我们使用folktale中的 Task来掩饰 folktale 一个标准的函数试变成库 和lodash、ramda不同的是，没有 提供很多功能函数 什么是函数式编程函数式编程(function Programming, FP)是编程范式之一，我们常听说的变成范式还有面向过程编程、面向对象编程。 面向对象编程的思维方式：把现实世界中的事物抽象成程序世界中的类和对象，通过封装、继承和多态来演示事物和事件的联系 函数式编程的思维方式：把现实世界的事物和事物之间的联系抽象到程序世界（对运算过程进行抽象） 程序的本质：根据输入通过某中运算获得相应的输出，程序开发过程中会涉及很多有输入和输出的函数 x -&gt; f(联系、映射)-&gt; y, y&#x3D;f(x) 函数式编程中的函数指的不是程序中的函数（方法），而是数学中的函数即映射关系，例如：&#96;&#96;&#96;y &#x3D; sin(x)，x和y的关系 相同的输入始终要得到相同的输出（纯函数） 函数式编程用来描述数据（函数）之间的映射 函数是一等公民高阶函数闭包函数是一等公民 函数可以存储在变量中 函数可以作为参数 函数作为返回值 在javascript中函数就是一个普通的对象（可以通过 new function()），我们可以把函数存储到变量或者数组中，它还可以作为另一个函数的参数和返回值，甚至我们可以在程序运行的时候通过new function(`alert(1)`)来构造一个新的函数。 1.把函数赋值给变量 2. 高阶函数 可以把函数作为参数传递给另一个参数 可以把函数作为另一个函数的返回结果 2.1高阶函数-函数作为返回值 2.2高阶函数的意义意义： 抽象可以帮我们屏蔽细节，只需要关注我们的目标 高阶函数是用来抽象通用的问题 "},{"title":"eggConfig","date":"2023-03-23T14:40:12.000Z","url":"/posts/6268065.html","tags":[["node","/tags/node/"]],"categories":[["node","/categories/node/"]],"content":"我们推荐直接使用脚手架，只需几条简单指令，即可快速生成项目 启动项目 目录结构 路由相关1. get传值 2. 4种配置方法 重定向1. ctx 2. 路由重定向 3.路由分组 控制器自定义 Controller 基类 此时在编写应用的 Controller 时，可以继承 BaseController，直接使用基类上的方法： 模板引擎1. 安装和使用ejs（1）安装 （2）配置：&#x2F;configconfig&#x2F;config.default.js （3）使用app&#x2F;controller app&#x2F;view&#x2F;index.html 服务（模型）控制器调用home 模型的test 方法 模型之间相互调用（同上） 模型和数据库配置和创建迁移文件配置 安装并配置egg-sequelize插件（它会辅助我们将定义好的 Model 对象加载到 app 和 ctx 上）和mysql2模块： 在config/plugin.js 中引入 egg-sequelize 插件 在config/config.default.js sequelize 提供了sequelize-cli工具来实现Migrations，我们也可以在 egg 项目中引入 sequelize-cli。 egg 项目中，我们希望将所有数据库 Migrations 相关的内容都放在database目录下，所以我们在项目根目录下新建一个.sequelizerc配置文件： 初始化 Migrations 配置文件和目录 行完后会生成database/config.json文件和database/migrations目录，我们修改一下database/config.json中的内容，将其改成我们项目中使用的数据库配置： 创建数据库 创建数据迁移表 执行完命令后，会在database &#x2F; migrations &#x2F; 目录下生成数据表迁移文件，然后定义 执行 migrate 进行数据库变更 已创建新增字段 创建迁移文件： 执行完命令后，会在database &#x2F; migrations &#x2F; 目录下生成数据表迁移文件，然后定义 执行 migrate 进行数据库变更 创建模型 这个 Model 就可以在 Controller 和 Service 中通过 app.model.User 或者 ctx.model.User 访问到了，例如我们编写 app/controller/users.js： 最后我们将这个 controller 挂载到路由上： 针对 users 表的 CURD 操作的接口就开发完了 模型其他参数 sequelize 命令 命令 含义 sequelize db:migrate 运行迁移文件 sequelize db:migrate:status 列出所有迁移的状态 sequelize db:migrate:undo 隔离数据库：迁移：撤消 sequelize db:migrate:undo:all 还原所有运行的迁移 sequelize db:create 创建由配置指定的数据库 sequelize db:drop 删除由配置指定的数据库 外键约束（重要） 创建第一个种子假设我们希望在默认情况下将一些数据插入到几个表中. 如果我们跟进前面的例子,我们可以考虑为 User 表创建演示用户. 要管理所有数据迁移,你可以使用 seeders. 种子文件是数据的一些变化,可用于使用样本数据或测试数据填充数据库表. 让我们创建一个种子文件,它会将一个演示用户添加到我们的 User 表中. 这个命令将会在 seeders 文件夹中创建一个种子文件.文件名看起来像是 XXXXXXXXXXXXXX-demo-user.js,它遵循相同的 up/down 语义,如迁移文件. 现在我们应该编辑这个文件,将演示用户插入User表. 运行种子在上一步中,你创建了一个种子文件. 但它还没有保存到数据库. 为此,我们需要运行一个简单的命令. 这将执行该种子文件,你将有一个演示用户插入 User 表. 注意: seeders 执行不会存储在任何使用 SequelizeMeta 表的迁移的地方. 如果你想覆盖这个,请阅读 存储 部分 撤销种子Seeders 如果使用了任何存储那么就可以被撤消. 有两个可用的命令 如果你想撤消最近的种子 如果你想撤消特定的种子 如果你想撤消所有的种子 关联操作一对一模型层： 控制器调用： 一对多 多对多 关联常用操作 获取器和修改器模型层 控制器层 模型钩子模型层 查询主键查询 查找不存在则创建方法 findOrCreate 可用于检查数据库中是否已存在某个元素. 如果是这种情况,则该方法将生成相应的实例. 如果元素不存在,将会被创建. 如果是这种情况,则该方法将导致相应的实例. 如果元素不存在,将会被创建. 假设我们有一个空的数据库,一个 User 模型有一个 username 和 job. 代码创建了一个新的实例. 所以当我们已经有一个实例了 … 现有条目将不会更改. 看到第二个用户的 “job”,并且实际上创建操作是假的. 查找并计数findAndCountAll - 在数据库中搜索多个元素,返回数据和总计数 这是一个方便的方法,它结合了 findAll 和 count(见下文),当处理与分页相关的查询时,这是有用的,你想用 limit 和 offset 检索数据,但也需要知道总数与查询匹配的记录数: 处理程序成功将始终接收具有两个属性的对象: count - 一个整数,总数记录匹配where语句和关联的其它过滤器 rows - 一个数组对象,记录在limit和offset范围内匹配where语句和关联的其它过滤器, 它支持 include. 只有标记为 required 的 include 将被添加到计数部分: 假设你想查找附有个人资料的所有用户: 因为 Profile 的 include 有 required 设置,这将导致内部连接,并且只有具有 profile 的用户将被计数. 如果我们从 include 中删除required,那么有和没有 profile 的用户都将被计数. 在include中添加一个 where 语句会自动使它成为 required:&#96;&#96; 上面的查询只会对具有 active profile 的用户进行计数,因为在将 where 语句添加到 include 时,required 被隐式设置为 true. 传递给 findAndCountAll 的 options 对象与 findAll 相同(如下所述). 查询多个（常用） 复合过滤 &#x2F; OR &#x2F; NOT 查询你可以使用多层嵌套的 AND,OR 和 NOT 条件进行一个复合的 where 查询. 为了做到这一点,你可以使用 or , and 或 not 运算符: 这两段代码将生成以下内容: not 示例: 将生成: 用限制,偏移,顺序和分组操作数据集要获取更多相关数据,可以使用限制,偏移,顺序和分组: 分组和排序的语法是相同的,所以下面只用一个单独的例子来解释分组,而其余的则是排序. 你下面看到的所有内容也可以对分组进行 请注意,在上述两个示例中,提供的字符串逐字插入到查询中,所以不会转义列名称. 当你向 order &#x2F; group 提供字符串时,将始终如此. 如果要转义列名,你应该提供一个参数数组,即使你只想通过单个列进行 order &#x2F; group 回顾一下,order &#x2F; group数组的元素可以是以下内容: String - 将被引用 Array - 第一个元素将被引用,第二个将被逐字地追加 Object - raw 将被添加逐字引用 如果未设置 raw,一切都被忽略,查询将失败 Sequelize.fn 和 Sequelize.col 返回函数和引用的列名 字段过滤想要只选择某些属性,可以使用 attributes 选项. 通常是传递一个数组: 属性可以使用嵌套数组来重命名: 也可以使用 sequelize.fn 来进行聚合: 使用聚合功能时,必须给它一个别名,以便能够从模型中访问它. 在上面的例子中,你可以使用 instance.get(&#39;no_hats&#39;) 获得帽子数量. 有时,如果你只想添加聚合,则列出模型的所有属性可能令人厌烦: 同样,它也可以排除一些指定的表字段: Where无论你是通过 findAll&#x2F;find 或批量 updates&#x2F;destroys 进行查询,都可以传递一个 where 对象来过滤查询. where 通常用 attribute:value 键值对获取一个对象,其中 value 可以是匹配等式的数据或其他运算符的键值对象. 也可以通过嵌套 or 和 and 运算符 的集合来生成复杂的 AND&#x2F;OR 条件. 基础 操作符Sequelize 可用于创建更复杂比较的符号运算符 - 范围选项所有操作符都支持支持的范围类型查询. 请记住,提供的范围值也可以定义绑定的 inclusion&#x2F;exclusion. 组合 关系 &#x2F; 关联 分页 &#x2F; 限制 排序order 需要一个条目的数组来排序查询或者一个 sequelize 方法.一般来说,你将要使用任一属性的 tuple&#x2F;array,并确定排序的正反方向. count - 计算数据库中元素的出现次数还有一种数据库对象计数的方法: max - 获取特定表中特定属性的最大值这里是获取属性的最大值的方法: min - 获取特定表中特定属性的最小值这里是获取属性的最小值的方法: sum - 特定属性的值求和为了计算表的特定列的总和,可以使用“sum”方法. 预加载当你从数据库检索数据时,也想同时获得与之相关联的查询,这被称为预加载.这个基本思路就是当你调用 find 或 findAll 时使用 include 属性.让我们假设以下设置: 首先,让我们用它们的关联 user 加载所有的 task. 请注意,访问者(结果实例中的 User 属性)是单数形式,因为关联是一对一的. 接下来的事情:用多对一的关联加载数据！ 请注意,访问者(结果实例中的 Tasks 属性)是复数形式,因为关联是多对一的. 如果关联是别名的(使用 as 参数),则在包含模型时必须指定此别名. 注意用户的 Tool 如何被别名为 Instruments. 为了获得正确的权限,你必须指定要加载的模型以及别名: 你还可以通过指定与关联别名匹配的字符串来包含别名: 当预加载时,我们也可以使用 where 过滤关联的模型. 这将返回 Tool 模型中所有与 where 语句匹配的行的User. 当使用 include.where 过滤一个预加载的模型时,include.required 被隐式设置为 true. 这意味着内部联接完成返回具有任何匹配子项的父模型. 使用预加载模型的顶层 WHERE将模型的 WHERE 条件从 ON 条件的 include 模式移动到顶层,你可以使用 &#39;$nested.column$&#39; 语法: 包括所有要包含所有属性,你可以使用 all:true 传递单个对象: 包括软删除的记录如果想要加载软删除的记录,可以通过将 include.paranoid 设置为 false 来实现 排序预加载关联在一对多关系的情况下. 在多对多关系的情况下,你还可以通过表中的属性进行排序. 嵌套预加载你可以使用嵌套的预加载来加载相关模型的所有相关模型: 这将产生一个外连接. 但是,相关模型上的 where 语句将创建一个内部连接,并仅返回具有匹配子模型的实例. 要返回所有父实例,你应该添加 required: false. 以上查询将返回所有用户及其所有乐器,但只会返回与 Woodstock Music School 相关的老师. 包括所有也支持嵌套加载: 新增字段限制 新增单个 批量新增 修改字段限制 单个修改 批量修改 递增 递减 删除软删除模型中配置 查询包括软删除内容 彻底删除如果 paranoid 选项为 true,则不会删除该对象,而将 deletedAt 列设置为当前时间戳. 要强制删除,可以将 force: true 传递给 destroy 调用: 在 paranoid 模式下对象被软删除后,在强制删除旧实例之前,你将无法使用相同的主键创建新实例. 恢复软删除的实例如果你使用 paranoid:true 软删除了模型的实例,之后想要撤消删除,请使用 restore 方法: 条件删除 批量删除 重载实例如果你需要让你的实例同步,你可以使用 reload 方法. 它将从数据库中获取当前数据,并覆盖调用该方法的模型的属性. 模型自定义方法 Scopes - 作用域（重点）作用域允许你定义常用查询,以便以后轻松使用. 作用域可以包括与常规查找器 where, include, limit 等所有相同的属性. 定义作用域在模型定义中定义,可以是finder对象或返回finder对象的函数,除了默认作用域,该作用域只能是一个对象: 通过调用 addScope 定义模型后,还可以添加作用域. 这对于具有包含的作用域特别有用,其中在定义其他模型时可能不会定义 include 中的模型. 始终应用默认作用域. 这意味着,通过上面的模型定义,Project.findAll() 将创建以下查询: 可以通过调用 .unscoped(), .scope(null) 或通过调用另一个作用域来删除默认作用域: 还可以在作用域定义中包含作用域模型. 这让你避免重复 include,attributes 或 where 定义. 使用上面的例子,并在包含的用户模型中调用 active 作用域(而不是直接在该 include 对象中指定条件): 使用通过在模型定义上调用 .scope 来应用作用域,传递一个或多个作用域的名称. .scope 返回一个全功能的模型实例,它具有所有常规的方法:.findAll,.update,.count,.destroy等等.你可以保存这个模型实例并稍后再次使用: 作用域适用于 .find, .findAll, .count, .update, .increment 和 .destroy. 可以通过两种方式调用作为函数的作用域. 如果作用域没有任何参数,它可以正常调用. 如果作用域采用参数,则传递一个对象: 合并通过将作用域数组传递到 .scope 或通过将作用域作为连续参数传递,可以同时应用多个作用域. 如果要将其他作用域与默认作用域一起应用,请将键 defaultScope 传递给 .scope: 当调用多个作用域时,后续作用域的键将覆盖以前的作用域(类似于 Object.assign),除了where和include,它们将被合并. 考虑两个作用域: 调用 .scope(&#39;scope1&#39;, &#39;scope2&#39;) 将产生以下查询 注意 scope2 将覆盖 limit 和 age,而 firstName 被保留. limit,offset,order,paranoid,lock和raw字段被覆盖,而where被浅层合并(意味着相同的键将被覆盖). include 的合并策略将在后面讨论. 请注意,多个应用作用域的 attributes 键以这样的方式合并,即始终保留 attributes.exclude. 这允许合并多个作用域,并且永远不会泄漏最终作用域内的敏感字段. 将查找对象直接传递给作用域模型上的findAll(和类似的查找程序)时,适用相同的合并逻辑: 这里的 deleted 作用域与 finder 合并. 如果我们要将 where: &#123; firstName: &#39;john&#39;, deleted: false &#125; 传递给 finder,那么 deleted 作用域将被覆盖. 合并 includeInclude 是根据包含的模型递归合并的. 这是一个非常强大的合并,在 v5 上添加,并通过示例更好地理解. 考虑四种模型:Foo,Bar,Baz和Qux,具有如下多种关联: 现在,考虑Foo上定义的以下四个作用域: 这四个作用域可以很容易地深度合并,例如通过调用 Foo.scope(&#39;includeEverything&#39;, &#39;limitedBars&#39;, &#39;limitedBazs&#39;, &#39;excludeBazName&#39;).findAll(),这完全等同于调用以下内容: 观察四个作用域如何合并为一个. 根据所包含的模型合并作用域的include. 如果一个作用域包括模型A而另一个作用域包括模型B,则合并结果将包括模型A和B.另一方面,如果两个作用域包括相同的模型A,但具有不同的参数(例如嵌套include或其他属性) ,这些将以递归方式合并,如上所示. 无论应用于作用域的顺序如何,上面说明的合并都以完全相同的方式工作. 如果某个参数由两个不同的作用域设置,那么只会该顺序产生差异 - 这不是上述示例的情况,因为每个作用域都做了不同的事情. 这种合并策略的工作方式与传递给.findAll,.findOne等的参数完全相同. 关联Sequelize 与关联有两个不同但相关的作用域概念. 差异是微妙但重要的: 关联作用域 允许你在获取和设置关联时指定默认属性 - 在实现多态关联时很有用. 当使用get,set,add和create相关联的模型函数时,这个作用域仅在两个模型之间的关联上被调用 关联模型上的作用域 允许你在获取关联时应用默认和其他作用域,并允许你在创建关联时传递作用域模型. 这些作用域都适用于模型上的常规查找和通过关联查找. 举个例子,思考模型Post和Comment. Comment与其他几个模型(图像,视频等)相关联,Comment和其他模型之间的关联是多态的,这意味着除了外键 commentable_id 之外,注释还存储一个commentable列. 可以使用 association scope 来实现多态关联: 当调用 post.getComments() 时,这将自动添加 WHERE commentable = &#39;post&#39;. 类似地,当向帖子添加新的注释时,commentable 会自动设置为 &#39;post&#39;. 关联作用域是为了存活于后台,没有程序员不必担心 - 它不能被禁用. 有关更完整的多态性示例,请参阅 关联作用域 那么考虑那个Post的默认作用域只显示活动的帖子:where: &#123; active: true &#125;. 该作用域存在于相关联的模型(Post)上,而不是像commentable 作用域那样在关联上. 就像在调用Post.findAll() 时一样应用默认作用域,当调用 User.getPosts() 时,它也会被应用 - 这只会返回该用户的活动帖子. 要禁用默认作用域,将 scope: null 传递给 getter: User.getPosts(&#123; scope: null &#125;). 同样,如果要应用其他作用域,请像这样: 如果要为关联模型上的作用域创建快捷方式,可以将作用域模型传递给关联. 考虑一个快捷方式来获取用户所有已删除的帖子: 扩展extend&#x2F;helper.js 模板中调用 其他地方调用 中间件1. 定义app&#x2F;middleware&#x2F;getIp.js 2. 配置config&#x2F;config.default.js（配置全局中间件，所有路由都会调用） 3. 使用路由中使用app&#x2F;router.js 使用 Koa 的中间件（gzip压缩）大大提高网站的访问速度（非常有效） 以 koa-compress 为例，在 Koa 中使用时: 我们按照框架的规范来在应用中加载这个 Koa 的中间件： 表单提交postapp&#x2F;controller&#x2F;home.js app&#x2F;view&#x2F;post.html app&#x2F;router.js cookie session 定时任务 API1. contextcurl 常用插件缓存 验证 加密 前端访问：header头添加： "},{"title":"css","date":"2023-03-23T14:39:08.000Z","url":"/posts/78cea6d8.html","tags":[["通用","/tags/%E9%80%9A%E7%94%A8/"]],"categories":[["通用","/categories/%E9%80%9A%E7%94%A8/"]],"content":"公共样式 "},{"title":"react项目基本配置","date":"2023-03-23T14:37:06.000Z","url":"/posts/84d7d56.html","categories":[["react项目配置","/categories/react%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/"]],"content":"前言目前主要使用的脚手架是create-react-app这个脚手架，因为不想使用npm eject将脚手架隐藏的配置文件暴露出来，那么有没有其他办法实现一些基本的配置呢？ 主要配置eslint统一团队内的代码风格，还有呢就是使用less module，修改项目的主题色，这些配置。 第一步安装antd提供的craco 然后修改package.json 第二步 创建craco.config.js配置less module 然后在craco.config.js添加 第三步 创建postcss.config.js 因为在项目中主要使用的TypeScript，所以还要配置一下tsconfig.json文件 我们需要新建一个tsconfig.base.json 内容 修改tsconfig,json 第四步 配置eslint 安装完成之后，新建.eslintrc .eslintrc 不要急，到这里还没完， 需要新建一个.editorconfig配置文件 .editorconfig 最后附上我的vscode中的settings.json的配置settings.json 好了，到这里就结束了~~"},{"title":"浏览器篇","date":"2023-03-23T14:35:52.000Z","url":"/posts/da130f3a.html","tags":[["面试题系列","/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B3%BB%E5%88%97/"]],"categories":[["面试题","/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"]],"content":"从输入URL到页面加载的全过程 首先在浏览器中输入url 查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。 浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求； 操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录（保存最近的DNS查询缓存）； 路由器缓存： 如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存； lsp缓存：若上述均失败，继续向ISP搜索。 DNS域名解析：浏览器向DNS服务器发起请求，解析该url中的域名对应的IP地址.DNS服务器是基于UDP的，因此会用到UDP协议 建立TCP链接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP链接 发起HTTP请求：浏览器发起读取文件的HTTP请求，该请求报文作为TCP三次握手的第三次数据发送给给服务器 服务器响应请求并返回结果：服务器对浏览器的请求作出响应，并把对应的html文件发送给浏览器 关闭TCP链接：通过四次回收释放TCP链接 浏览器渲染：客户端（浏览器）解析HTML文件并渲染出来，浏览器接收到数据包后的解析流程为： 构建DOM树：词法分析然后解析成DOM树（don tree），是由DOM元素及属性节点组成，树的根是document对象 构建CSS规则树：生成CSS规则树（CSS Rule Tree） 构建render树：web浏览器会将DOM和CSSOM结合，并构建出渲染树（render Tree） 布局（layout）：计算出每个节点在屏幕中的位置 绘制（Painting）：遍历render树，并使用 UI后端层绘制每个节点。 js引擎解析过程： 调用js引擎执行js代码（js的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链，回收机制等） 创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的document对象上。当关闭网页或者浏览器时，全局执行环境会被销毁 加载文件：完成js引擎分析它的语法和词法是否合法，如果合法则进入预编译 预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为undefined；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给它，（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方已经在es6中解决了，函数提升还是存在的 解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在es5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string int这样的就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。js作用域其实就是这样的执行机制实现的 浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 强制缓存** 强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程 **。当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 Expires 和 Cache-Control，其中 Cache-Control 优先级比 Expires 高。强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下： 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果 协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified &#x2F; If-Modified-Since 和 Etag &#x2F; If-None-Match，其中Etag &#x2F; If-None-Match的优先级比Last-Modified &#x2F; If-Modified-Since高。协商缓存主要有以下两种情况： 协商缓存生效，返回304 协商缓存失效，返回200和请求结果结果 首先我们来说一下浏览器是由哪两部分组成？ 渲染引擎： 用来解析HTML和CSS，俗称内核，比如chrome浏览器的blink，老版本的webkit JS引擎： 也称为javascript解释器，用来读取网页中的javascript代码，对其处理后运行，比如chrome浏览器的V8 注： 浏览器并不会执行javascript代码，而是通过内置的js引擎(解释器)来执行javascript代码javascript引擎执行代码时逐行解释每一句源码(转换为机器语言)，然后由计算机去执行，所以javascript语言归为脚本语言，会逐行解释执行 补充 大多数浏览器（chrome）让一个单线程供用于执行JavaScript和更新用户界面。这个线程通常被称为”浏览器UI线程”，每个时刻只能执行其中一种操作，这意味着当JavaScript代码正在执行时用户界面无法响应输入，反之亦然。这样做是因为JavaScript代码的作用就是操作DOM更新用户页面，用同一个线程来做这两件事情可以更高效。 浏览器UI线程的工作基于一个简单的队列系统，任务会被保存到队列中直到进程空闲。一旦空闲，队列中的下一个任务就被重新提取出来并运行。这些任务要么是运行javascript代码，要么执行UI更新，包括重绘和重排。 重要的事情说三遍，javascript是单线程运行 -- 单线程运行 -- 单线程运行，千万不要被setTimeout()和setInterVal()这种函数迷惑而误以为它是多线程。 接下来直入主题1.原理一般来说，&lt;script&gt;标签每次出现都会霸道的让页面等待脚本的解析和执行。无论当前的JavaScript 是内嵌的还是包含了外链文件，页面的下载和渲染都必须停下来等待脚本执行完成。这在页面的生存周期是必要的，因为脚本的执行过程可能会改变页面的内容。 比如在页面中使用document.write()。方法可向文档写入 HTML 表达式或 JavaScript 代码 当javascript代码是内嵌在html里面时，这点还是比较容易理解，但当javascript是外链文件时稍微有点负载，因为存在一个加载过程，而且浏览器加载好这个js文件之后往往还对其缓存。 例子 当一个javascript文件被加载时是否会阻塞其他javascript文件或者其他文件的加载呢？ 答案是：各种浏览器的低版本的处理是当一个js文件在加载时，会同时阻塞页面其他文件的加载。（包括其他的js文件）但是ie8、Firfox3.5、Safari 4和Chrome 2都允许并行下载javascript文件，但是呢，javascript下载过程仍然会阻塞其他资源的下载，比如图片。尽管javascript脚本的下载过程不会相互影响，但页面仍然必须等待所有的javascript代码下载并执行完成才能继续。 2. 优化的方法（技巧） 由于脚本会阻塞页面其他资源的下载，因此我们一般将所有的&lt;script&gt;标签放到&lt;body&gt;标签的底部，已尽量减少对整个页面下载的影响。 将能合并的js文件合并 无阻塞脚本 现在比较常用的方法就是动态加载执行脚本。原理是DOM,可以通过js动态的创建HTML中所有的内容，其根本在于&lt;script&gt;标签与页面中其他元素并无差异，都能通过DOM引用，都能在文档中移动，删除和创建。文件在该&lt;script&gt;元素被添加到页面时开始现在，它不会阻止其他文件下载，只在执行阶段阻塞渲染。这种方法并不是说它在执行不会阻塞其他javascript代码，而是不会阻塞其他资源的下载等其他任务。 "},{"title":"javascript基本算法","date":"2023-03-23T14:34:48.000Z","url":"/posts/9505ccb9.html","categories":[["随笔","/categories/%E9%9A%8F%E7%AC%94/"]],"content":"前言在前端面试的过程中我们必须要会的一个技能就是算法，一般来说面试中高级前端工程师的时候会要求会算法，至于校招考不考算法我就不知道了，话不多说就让我们开始吧！ 时间复杂度O(1) O(n) O(n) * O(n) &#x3D; O(n^2) O(logN) 空间复杂度简述： 1、一个函数，用大O表示，比如O(1)、O(N)、O(n^2)…… 2、算法唉运行过程中临时占用存储空间大小的量度 O(1) O(n) O(n^2) 栈简介栈是什么？ 一个后进先出的数据结构 应用场景 十进制转二进制、判断z字符串的括号是否有效、函数调用堆栈 例子给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。思路符合后进先出考虑用栈 新建一个栈 扫描字符串，遇左括号入栈，遇到和栈顶括号类型匹配的有括号出栈，类型不符合之间判定为不合法 js中的函数调用堆栈 链表简介链表是什么？ 多个元素组成的列表 元素存储不连续，用next指针连在一起 数组VS链表 数组：增删非首尾元素时往往需要移动元素 链表：增删首尾元素，不需要移动元素，只需要更改next指向即可 JS中的链表 js中没有链表 可以用Object模拟链表 leetCode 237 删除链表中的节点 LeetCode 206 反转链表思路 反转两个节点：将n+1的next指向n 反转多个节点：双指针遍历链表 "},{"title":"htmlOrcss","date":"2023-03-23T14:24:24.000Z","url":"/posts/20e59239.html","categories":[["html&css","/categories/html-css/"]],"content":"前言回顾一下面试中常问的html和css，温故而知新 DOCTYPE(⽂档类型) 的作⽤DOCTYPE是html5中一种标准通用标记语言的文档类型声明，它的目的是告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对css代码甚至JavaScript脚本的解析。 注意：必须声明在HTML文件中的第一行 浏览器渲染页面的两种模式（document.compatMode） css1Compat: 标准模式（Strick mode）默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。 BackCompat: 怪异模式(混杂模式)(Quick mode)，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。 你知道html中哪些语义化标签 为什么会有语义化标签出现 利于开发：结构清晰、可读性高、方便维护 利于SEO：方便爬虫根据语义标签确定页面结构和关键字的权重 title、description、keyword meta viewport是做什么的，怎么写？禁止页面在移动端缩放 name为viewport表示移动设备使用 content定义了viewport的属性： width表示宽度为设备宽度（兼容苹果） initial-scale表示设备与视口的缩放比率（兼容IE） 你用过哪些 meta 标签属性 其中，content参数有一下六种 width viewport: 宽度(数值&#x2F;device-width) height viewport: 高度(数值&#x2F;device-height) initial-scale: 初始缩放比例 maximum-scale: 最大缩放比例 minimum-scale: 最小缩放比例 user-scalable: 是否允许用户缩放(yes&#x2F;no） 搜索引擎索引方式： all：文件将被检索，且页面上的链接可以被查询； none：文件将不被检索，且页面上的链接不可以被查询； index：文件将被检索 follow：页面上的链接可以被查询； noindex：文件将不被检索 nofollow：页面上的链接不可以被查询。 script标签中defer和async的区别如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。 defer和async属性都是去异步加载外部的JS脚本文件，他们都不会阻塞页面的解析，区别如下： 执行顺序： 多个带async属性的标签，不能保证加载的顺序 多个带defer属性的标签，按照加载顺序执行 脚本是否并行执行 async属性，表示后续文档的加载和执行与js脚本的加载和执行是并行执行的，即异步执行 defer属性，加载后续文档的过程和js脚本的加载是并行的，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前 HTML、XML、XHTML 的区别 HTML：超文本标记语言，是语法较为松散、不严的web语言； XML：可扩展的标记语言，主要用于存储数据和结构，可扩展 XHTML：可扩展的超文本标记语言，基于XML，作用与HTML类似，但语法更严格 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 行内元素： a、b、span、img、input、select、strong 块级元素：div、ul、li、dl、dt、dd、p 空元素：&lt;br&gt;、&lt;hr&gt;、&lt;img /&gt;、&lt;link/&gt; 标签上title属性与alt属性的区别是什么 alt是为了在图片未能正常显示时（屏幕阅读器）给予文字说明。且长度必须少于100个英文字符或者用户必须保证替换文字尽可能的短。 title属性为设置该属性的元素提供建议性的信息。使用title属性提供非本质的额外信息。 head 标签有什么作用，其中什么标签必不可少？标签用于定义文档的头部，它是所有头部元素的容器。 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。 文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。 下面这些标签可用在 head 部分：&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, &lt;title&gt;。 其中 &lt;title&gt; 定义文档的标题，它是 head 部分中唯一必需的元素。 src与href有什么区别src用于替换当前元素；href用于在当前文档和引用资源之间确立联系； src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置； 而href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接。 为什么利用多个域名来存储网站资源会更有效 CDN缓存更加方便 突破浏览器并发限制； 节约cookie宽带； 节约主域名的连接数，优化页面下响应速度； 防止不必要的安全问题； 对比一下cookie和sessioncookie和session都是用来跟踪浏览器用户身份的会话方式。 区别: 1.保持状态：cookie保存在浏览器端，session保存在服务器端 2.使用方式： cookie机制： 如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称会话cookie。 如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期时间结束才消失。 Cookie是服务器发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它。 session机制： 当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。 通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url) 进行实现；API对encodeURL的结束为，当浏览器支持Cookie时，url不做任何处理；当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。3.存储内容： cookie只能保存字符串类型，以文本的方式； session通过类似与Hashtable的数据结构来保存，能支持任何类型的对象(session中可含有多个对象)。4.存储的大小： cookie：单个cookie保存的数据不能超过4kb； session大小没有限制。5.安全性： cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获； session的安全性大于cookie。 原因如下： sessionID存储在cookie中，若要攻破session首先要攻破cookie； sessionID是要有人登录，或者启动session_start才会有，所以攻破cookie也不一定能得到sessionID； 第二次启动session_start后，前一次的sessionID就是失效了，session过期后，sessionID也随之失效。 sessionID是加密的 6.缺点： cookie： 大小受限 用户可以操作（禁用）cookie，使功能受限 安全性较低 有些状态不可能保存在客户端。 每次访问都要传送cookie给服务器，浪费带宽。 cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。 session： Session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。 依赖于cookie（sessionID保存在cookie），如果禁用cookie，则要使用URL重写，不安全。 创建Session变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以，过度使用session变量将会导致代码不可读而且不好维护。 HTML5的十大新特性 语义标签 增强型表单 视频和音频 Canvas绘图 SVG绘图 地理定位 Geolocation 拖放API Web Worker Web Storage WebSocket 说一下 web worker在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。 如何创建 web worker： 检测浏览器对于 web worker 的支持性 创建 web worker 文件（js，回传函数等） 创建 web worker 对象 说一下 HTML5 drag API dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。 darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。 dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。 dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。 dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。 drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。 dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。 "}]