[{"title":"vscode中settings配置","date":"2023-03-23T14:55:33.000Z","url":"/posts/849a3ae4.html","categories":[["通用","/categories/%E9%80%9A%E7%94%A8/"]],"content":"vsCode中setting基本配置项目中总结出来的一些相关配置 "},{"title":"react常用hooks","date":"2023-03-23T14:53:59.000Z","url":"/posts/8ae780ab.html","categories":[["react","/categories/react/"]],"content":"useOnce类似于componentDidMount 使用方法 EventBus事件的发布订阅 使用方法 useSearchParams获取地址栏参数(all) 使用 "},{"title":"react基础","date":"2023-03-23T14:52:31.000Z","url":"/posts/b172fb3f.html","categories":[["面试题","/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"]],"content":"组件基础1、react事件绑定原理 react 并不是将click事件绑定到了div真实的DOM上，而是在document处监听了所有的事件，当事件发生并且冒泡到document处的时候，react 将事件内容封装并交由真正的处理函数执行。这样的方式不仅仅减少了内存的消耗，还能在组件挂载销毁时统一订阅和移除事件。 还有， 冒泡到document上的事件也不是原生的浏览器事件，而是由react自己合成的事件，所以不想要事件冒泡的话应该调用event.preventDefault()方法，而不是调用event.stopProppagation()方法 2、React的事件和普通的HTML事件有什么不同？区别： 对于事件名称的命名方式，原生事件为全小写，而react 事件采用小驼峰 对于事件函数处理语法，原生事件为字符串，react 事件为函数 react 事件不能采取return false的方法来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为 合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象 优点 兼容所有的浏览器，更好的跨平台 将事件统一存放在一个数组，避免频繁的新增和删除（垃圾回收） 方便react统一管理和事件机制 3、 React 组件中怎么做事件代理？它的原理是什么？react基于Virtual DOM实现一个事件合成层，定义的事件处理器会接收到一个合成事件对象的实例。它符合W3CW标准，且与原生浏览器事件有相同的接口。支持冒泡事件，所有的事件都自动绑定在最外层。 在React底层，主要对合成事件做了：事件委派和自动绑定。 事件委派： react会把所有事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上w维持了一个映射来保存s所有组件内部事件监听和处理函数 自动绑定： react组件中，每个方法的上下文都对指向该组件的实例，即自动绑定 this 为当前组件 4、React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代这三个是目前react解决代码复用的主要方式。 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。 render props是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术，更具体的说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。 通常，render props 和高阶组件只渲染一个子节点。让 Hook 来服务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个虚拟滚动条组件或许会有一个 renderltem 属性，或是一个可见的容器组件或许会有它自己的 DOM 结构）。但在大部分场景下，Hook 足够了，并且能够帮助减少嵌套。 HOC 官方解释∶ 简单的来说，HOC是一种组件的设计模式，HOC接受一个组件和额外的参数（如果需要），返回一个新的组件。HOC 是纯函数，没有副作用。 hoc的优缺点∶ 优点∶ 逻辑服用、不影响被包裹组件的内部逻辑 缺点：hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖 Render props 官方解释∶ 具有render prop 的组件接受一个返回 react 元素的函数，将render的渲染逻辑注入到组件内部，在这里 render 的命名可以使其他有效的标识符 jsx 由此可以看到，render props的优缺点也很明显∶ 优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。 缺点：无法在 return 语句外访问数据、嵌套写法不够优雅 Hooks 官方解释∶ jsx 以上可以看出，hook解决了hoc的prop覆盖的问题，同时使用的方式解决了render props的嵌套地狱的问题。hook的优点如下∶ 使用直观 解决hoc的prop 重名问题 解决render props 因共享数据 而出现嵌套地狱的问题 能在return之外使用数据的问题 需要注意的是∶hook只能在组件顶层使用，不可在分支语句中使用。 总结： Hoc、render props和hook都是为了解决代码复用的问题，但是hoc和render props都有特定的使用场景和明显的缺点。hook是react16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点。 5、对React-Fiber的理解，它解决了什么问题？React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们， 一气呵成。这个过程期间， React 会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，导致用户感觉到卡顿 为了给用户制造一种应用很快的“假象”，不能让一个任务长期霸占着资源。 可以将浏览器的渲染、布局、绘制、资源加载(例如 HTML 解析)、事件响应、脚本执行视作操作系统的“进程”，需要通过某些调度策略合理地分配 CPU 资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。 所以 React 通过Fiber 架构，让这个执行过程变成可被中断。“适时”地让出 CPU 执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处: 分批延时对DOM进行操作，避免一次性操作大量 DOM 节点，可以得到更好的用户体验； 给浏览器一点喘息的机会，它会对代码进行编译优化（JIT）及进行热代码优化，或者对 reflow 进行修正。__核心思想：__Fiber 也称协程、或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。 6、React.Component 和 React.PureComponent 的区别？pureComponent表示一个纯组件，可以用来优化react组件，减少render函数执行的次数，从而提高组件的性能 在react中，当props或state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。 不过，pureComponent中的shouldComponentUpdate()进行的是 浅比较 ，也就是说如果是 引用类型数据 ,只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性或状态突变情况。其实也就是数据引用指针没有变化。而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。 使用pureComponent的好处：当组件更新时，如果组件的props或state没有改变，render函数就不会触发。省去虚拟dom的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。 7、Component, Element, Instance 之间有什么区别和联系？元素: 一个元素element是一个普通对象，描述了对于一个DOM节点或者其他组件component,你想让他在屏幕中呈现什么样子。素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。 组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。 实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。 函数试组件根本没有instance实例，类组件有实例，但是永远也不要直接创建一个组件的实例，因为react已经帮我们做了这些。 8、对componentWillReceiveProps 的理解该生命周期函数只有在props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取，这里调用更新状态是安全的。并不会触发额外的render调用。 使用好处： 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。componentWillReceiveProps(nextProps)在初始化render的时候不会执行，它会在component接收到新的props（状态）时被触发，一遍用于父组件状态更新时子组件重新渲染。 9、哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？1、哪些方法会触发 react 重新渲染? setState()方法被调用 setState是react中最常用的命令，通常情况下，执行setState会触发render。但是这里有个点需要注意一下，执行setState的时候一定会重新渲染吗？答案是不一定，当setState传入null的时候，并不会触发render。 父组件重新渲染只有父组件重新渲染了，即使传入子组件的props未发生变化，那么子组件也会重新渲染，进而触发render 2、重新渲染render会做些什么？ 会对新旧Vnode进行对比，也就是我们所说的diff算法 对新旧两颗树进行一个深度优先遍历，这样每一个节点都会有一个标记，在到深度遍历的时候，每遍历到一个节点。就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面 遍历差异对象，根据差异的类型，根据应对规则更新Vnode react的处理Render的基本思维模式是每次一有变动就会去重新渲染整个应用。在虚拟dom没出现之前，最简单的方法就是直接调用innerHTML。虚拟dom厉害的地方并不是说他比直接操作dom快，而是说不管数据怎么变，都会尽量以最小的代价去更新dom，react将render函数返回的虚拟dom树与老的进行比较，从而确定dom要不要更新、怎么更新。当DOM树很大时，遍历两棵树进行各种比对是相当耗性能的，特别是在顶层setState一个微小的修改，默认回去遍历整颗树。尽管react使用高度优化的diff算法，但是这个过程仍会损耗性能。 10、React如何判断什么时候重新渲染组件？组件状态的改变可以因为props的改变，或者直接通过setState方法改变。组件获得新的状态然后React决定是否应该重新渲染组件。只要组件的State发生变化，react就会对组件进行重新渲染。这是因为react中的shouldComponentUpdate方法默认返回 true，这就是导致每次更新都重新渲染的原因。 当react将要渲染组件时会执行shouldComponentUpdate方法来看它是否返回true（组件应该更新，也就是重新渲染）。所以需要重写shouldComponentUpdate方法让它根据情况返回true或者false来告诉React什么时候重新渲染什么时候跳过重新渲染。 11、对有状态组件和无状态组件的理解及使用场景有状态组件 特点： 是一个类组件、有继承、可以使用this 可以使用react的生命周期 使用较多，容易频繁触发生命周期钩子函数，影响性能 内部使用state,维护自身状态的变化，有状态组件根据外部组件传入的props和自身的State进行渲染 使用场景 需要使用到状态的 需要使用状态操作组件的（无状态组件的也可以实现新版本react hooks也可以实现） 总结：类组件可以维护自身的状态变量，即组件的state,类组件还有不同的生命周期方法，可以让开发者能够在组件的不同阶段（挂载、更新、卸载），对组件做更多的控制。类组件既可以充当无状态组件，也可以充当有状态组件。当一个类组件不需要管理自身状态时，也可以被称为无状态组件。 无状态组件 特点 不依赖自身的状态state 可以使类组件或者函数组件 可以完全避免使用this关键字（由于使用的是箭头函数无需绑定） 有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态组件 组件内部不维护state，只根据外部组件传入的props进行渲染的组件，当props改变时，组件重新渲染 使用场景 组件不需要管理state，纯展示 有点 简化代码，专注render 组件不需要被实例化，无生命周期，提高性能。渲染只取决于属性，无副作用 视图和数据的解耦分离 缺点 无法使用ref和生命周期方法 无法控制组件的重渲染，因为无法使用shouldComponentUpdate方法，当组件接收到的属性时则会冲渲染 总结：组件内部状态且与外部无关的组件，可以考虑用五状态组件，这样状态数就不会过于复杂，易于理解和管理。当一个组件不需要管理自身状态时，也就是无状态组件，应该优先设计为函数组件。 12、对React中Fragment的理解，它的使用场景是什么？在react中，组件返回的元素只能有一个根元素。为了不添加多余的dom节点，我们可以使用Fragment标签来包裹所有的元素，Fragment标签不会渲染出任何元素。 13、在React中如何避免不必要的render？React基于虚拟DOM和高效diff算法的完美配合，实现了对DOM最小粒度的更新。大多情况下，react对DOM的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然存在。此时需要采取一些措施来提升运行性能，其很重要的一个方向就是尽可能的避免render shouldComponentUpdate和PureComponent 在react类组件中，可以利用shouldComponentUpdate或者pureComponent来减少因父组件更新而触发子组件render，从而达到目的。shouldComponentUpdate来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回false即可。 利用高阶组件 在函数组件中，并没有 shouldComponentUpdate这个生命周期，可以利用高阶组件，封装一个类似PureComponet的功能 使用React.memo React.mome是react16.0新的一个API，用来缓存组件的渲染，避免不必要的更新，其实也会死你一个高阶组件，与PureComponent十分类似，但不同的是React.memo只能用于函数组件。 14、对 React context 的理解在React中， 数据传递一般使用props传递数据，维持单项数据流，这样可以让组件之间的关系变得简单可预测，但是单向数据流在某些场景中并不适用。单纯一对的父子组件传递并无问题，但要是组件之间层层依赖深入，props就需要层层传递，显然这样做太繁琐了。 Context提供了一种在组件之间共享此类值得方法，而不必显式的通过组件树的逐层传递 props 可以把context当做是特定一个组件数内共享的store，用来做数据传递。简单的说就是，当年你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。 js的代码在执行期间，会创建一个相应的作用域链，这个作用域链记录这运行时js代码块执行期间所能访问的活动对象，包括变量和函数，js程序通过作用域链访问到代码块内部或者外部的变量和函数 假如以js的作用域链作为类比，react组件提供的context对象其实就是好比一个提供给子组件访问的作用域，而Context对象的属性可以看成作用域上的活动对象。由于组件的context由父节点链上所有组件通过getChildContext（）返回的context对象组合而成，所以组件通过context是可以访问到其父组件链上所有节点组件提供的context的属性。 15、为什么React并不推荐优先考虑使用Context？ context目前还处于实验阶段，可能会在后面发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来的影响和麻烦，不建议在app中使用context。 尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context； 对于组件之间的数据通信或者状态管理，有效使用props或者State解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳方案的时候，考虑context context的更新需要通过setState()触发，但是这并不是可靠的，context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如shouldComponentUpdate() 返回false那么不能保证context的更新一定可以使用context的子组件，因此，context的可靠性需要关注 16、React中refs的作用是什么？有哪些应用场景？Refs提供了一种方式，用于访问在 render方法中创建的react元素或DOM节点，refs应该谨慎使用，如下场景使用refs比较适合： 处理焦点、文本选择或者媒体的控制 触发必要的动画 集成第三方DOM库 注意： 不应该国度的使用refs ref的返回值取决于节点的类型 当ref属性被用于一个普通的HTML元素时，react.createRef()将接收底层DOM元素作为它的current属性以创建ref。 当ref属性被用于一个自定义的类组件时，ref对象将接收该组件已挂载的实例作为它的current 当在父组件中需要访问子组件中的ref时可使用传递refs或回调refs。 17、React组件的构造函数有什么作用？它是必须的吗？构造函数主要用于两个目的： 通过将对象分配给this.state来初始化本地状态 将事件处理程序方法绑定到实例上 所以，当在React class中需要设置state的初始值或者绑定事件时，需要加上构造函数，官方Demo: 构造函数用来新建父类的this对象；子类必须在constructor方法中调用super方法；否则新建实例时会报错；因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法；子类就得不到this对象。 注意： constructor() 必须配上super()，如果要在constructor内部使用this.props就要传入props，否则不用 js中的bind每次都会返回一个新的函数，为了性能等考虑，尽量在constructor中绑定事件 "},{"title":"H5常见机型适配","date":"2023-03-23T14:51:02.000Z","url":"/posts/47cf154e.html","categories":[["通用","/categories/%E9%80%9A%E7%94%A8/"]],"content":""},{"title":"工具函数","date":"2023-03-23T14:50:18.000Z","url":"/posts/6085e14f.html","categories":[["通用","/categories/%E9%80%9A%E7%94%A8/"]],"content":"localStorage的已使用空间在较新的chrome上测试，localStorage的存储是按照字符个数来算的。 包含键和值的。所以在测试代码中，你把a修改啊，不会影响存储的数量。 但是键的长度，会影响存储的数量。 示例 带图带事件的桌面通知 示例 原生30行代码实现视频截图基本原理就是把视频画到Canvas里面，然后调用toDataURL或者toBlob，再利用a标签模拟点击，download属性指定名字。 示例注意添加crossorigin=&quot;anonymous&quot;，不然转为图片会失败。 基于URLSearchParams或URL获取queryString的值常用的方式是使用正则或者split方法，其实不然，URLSearchParams和URL都能很好的实现功能。 示例 基于atob和btoa的base64编码和解码浏览器内置了base64编码和解码的能力，第三方库，不需要的。 示例 非正则替换的html代码encode和decode常规的方式是使用正则替换，这里是另外一种思路。 示例 相对地址转换为绝对地址 示例 基于URL或者Crypto.getRandomValues生成UUIDURL.createObjectURL 产生的地址为 blob:, 其后部分就是一个UUID 方法一 方法二 基于Array.from的序列生成器造有序数据，无序数据，等等。 示例 基于sendBeacon的安全的数据上报 示例 基于toLocaleString千分位正则？ 遍历？ 不需要的。内置函数就解决。当然，如果是超大的数，可能是会有问题的。 示例 Promise顺序执行让Promise顺序的执行，并支持初始化参数和结果作为参数传递。 示例 延时执行delay延时执行某函数，且只会执行一次。 示例 进度值映射进度映射，比较只有 10%的进度，确要显示50%的进度的场景。 示例 滑滚动页面到顶部PC端滚动的根元素是document.documentElement,移动端滚动的的根元素是document.body,有一个更好的属性document.scrollingElement能自己识别文档的滚动元素， 其在PC端等于document.documentElement, 其在移动端等于document.body 禁止选择和复制 CSS 禁止图片拖拽 自增长ID自己生产自增长的ID值，当然可以更复杂一些。 示例 "},{"title":"js常用方法","date":"2023-03-23T14:47:54.000Z","url":"/posts/11be3759.html","categories":[["通用","/categories/%E9%80%9A%E7%94%A8/"]],"content":"去除空格 防抖函数 跳转函数 字符串首字母变大写 日期格式化 填0函数 设置cookie uncode解码 加密&amp;&amp;解密 获取search中的数据 检测浏览器window.search是否有指定字段 延迟函数delay 分割指定长度的元素数组 获取数组交集 函数柯里化 字符串前面空格去除与替换 字符串后面空格去除与替换 获取当前子元素是其父元素下子元素的排位 获取当前元素相对于document的偏移量 获取元素类型 判断是否是移动端 fade动画 将指定格式的字符串解析为日期字符串 禁止网页复制粘贴 input框限制只能输入中文 去除字符串中的html代码 mac安装brew"},{"title":"js篇","date":"2023-03-23T14:46:44.000Z","url":"/posts/17c7b154.html","categories":[["面试题","/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"]],"content":"js中的事件循环机制进程、线程 进程是系统分配的独立资源，是CPU资源分配的基本单位，进程是由一个或者多个线程组成的。 线程是进程的执行流，是CPU调度和分派的基本单位，同个进程之中的多个线程之间是共享该进程资源的。 浏览器内核 浏览器内核有多种线程在工作 GUI渲染线程负责渲染页面，解析 HTML，CSS 构成 DOM 树等，当页面重绘或者由于某种操作引起回流都会调起该线程和 JS 引擎线程是互斥的，当 JS 引擎线程在工作的时候，GUI 渲染线程会被挂起，GUI 更新被放入在 JS 任务队列中，等待 JS 引擎线程空闲的时候继续执行。 JS 引擎线程单线程工作，负责解析运行 JavaScript 脚本。和 GUI 渲染线程互斥，JS 运行耗时过长就会导致页面阻塞。 事件触发线程:当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到任务队列的队尾，等待 JS 引擎处理。 定时器触发线程浏览器定时计数器并不是由 JS 引擎计数的，阻塞会导致计时不准确。开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待 JS 引擎处理。 http 请求线程http 请求的时候会开启一条请求线程。请求完成有结果了之后，将请求的回调函数添加到任务队列中，等待 JS 引擎处理。 JavaScript 引擎是单线程JavaScript 引擎是单线程，也就是说每次只能执行一项任务，其他任务都得按照顺序排队等待被执行，只有当前的任务执行完成之后才会往下执行下一个任务。HTML5 中提出了 Web-Worker API，主要是为了解决页面阻塞问题，但是并没有改变 JavaScript 是单线程的本质 JavaScript 事件循环机制JavaScript 事件循环机制分为浏览器和 Node 事件循环机制，两者的实现技术不一样，浏览器 Event Loop 是 HTML 中定义的规范，Node Event Loop 是由 libuv 库实现。这里主要讲的是浏览器部分。 Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。 JS 调用栈JS 调用栈是一种后进先出的数据结构。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。 同步任务、异步任务JavaScript 单线程中的任务分为同步任务和异步任务。同步任务会在调用栈中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。 Event Loop调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环。 定时器定时器会开启一条定时器触发线程来触发计时，定时器会在等待了指定的时间后将事件放入到任务队列中等待读取到主线程执行。 定时器指定的延时毫秒数其实并不准确，因为定时器只是在到了指定的时间时将事件放入到任务队列中，必须要等到同步的任务和现有的任务队列中的事件全部执行完成之后，才会去读取定时器的事件到主线程执行，中间可能会存在耗时比较久的任务，那么就不可能保证在指定的时间执行。 宏任务(macro-task)、微任务(micro-task)除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。 macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。 micro-task包括：process.nextTick, Promises, Object.observe, MutationObserver。 示例中，setTimeout 和 Promise被称为任务源，来自不同的任务源注册的回调函数会被放入到不同的任务队列中。 有了宏任务和微任务的概念后，那 JS 的执行顺序是怎样的？是宏任务先还是微任务先？ 第一次事件循环中，JavaScript 引擎会把整个 script 代码当成一个宏任务执行，执行完成之后，再检测本次循环中是否寻在微任务，存在的话就依次从微任务的任务队列中读取执行完所有的微任务，再读取宏任务的任务队列中的任务执行，再执行所有的微任务，如此循环。JS 的执行顺序就是每次事件循环中的宏任务-微任务。 上面的示例中，第一次事件循环，整段代码作为宏任务进入主线程执行。遇到了 setTimeout ，就会等到过了指定的时间后将回调函数放入到宏任务的任务队列中。遇到 Promise，将 then 函数放入到微任务的任务队列中。整个事件循环完成之后，会去检测微任务的任务队列中是否存在任务，存在就执行。第一次的循环结果打印为: 1,3,5,4。接着再到宏任务的任务队列中按顺序取出一个宏任务到栈中让主线程执行，那么在这次循环中的宏任务就是 setTimeout 注册的回调函数，执行完这个回调函数，发现在这次循环中并不存在微任务，就准备进行下一次事件循环。检测到宏任务队列中已经没有了要执行的任务，那么就结束事件循环。最终的结果就是 1,3,5,4,2。 js中微任务和宏任务的区别 宏任务：当前调用栈中执行的代码成为宏任务。（主代码快，定时器等等）。 微任务： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务,可以理解为回调事件。（promise.then，proness.nextTick等等）。 宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。 运行机制 在执行栈中执行一个宏任务。 执行过程中遇到微任务，将微任务添加到微任务队列中。 当前宏任务执行完毕，立即执行微任务队列中的任务。 当前微任务队列中的任务执行完毕，检查渲染，GUI线程接管渲染。 渲染完毕后，js线程接管，开启下一次事件循环，执行下一次宏任务（事件队列中取）。 微任务：process.nextTick、MutationObserver、Promise.then catch finally 宏任务：I&#x2F;O、setTimeout、setInterval、setImmediate、requestAnimationFrame"},{"title":"lerna搭建脚手架遇到的问题记录","date":"2023-03-23T14:44:57.000Z","url":"/posts/d1b186b.html","categories":[["问题记录","/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"]],"content":"前言使用lerna搭建了一个脚手架，打算发布到npm上去，记录一下遇到的问题 npm登录登录过程 这些输入之后一直处于一个登录状态，登录好长时间发现返回了一个Error: 500 Internal Server Error - PUT  因为之前一直用的是淘宝的源，所以想着是不是因为源的问题导致的 这里使用的是nrm没装这个的话自己去装一下 查看之后发现我之前直接设置的是淘宝源没有设置npm的源 这样npm源就设置好了然后，我们再次执行npm login 返回 证明就执行成功了！ 接下来就使用lerna发布npm 提示我package.json中存在淘宝源 导致报错 然后去lerna官网去查询发现只需要将 就可以了执行lerna publish然后就发布成功了！"},{"title":"http","date":"2023-03-23T14:43:32.000Z","url":"/posts/97780db2.html","categories":[["面试题","/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"]],"content":"http和https1.http和https基本概念http: 是一个客户端和服务器端请求和应答标准（TCP），用于从www服务器传输超文本到本地浏览器的超本文传输协议。 https: 是安全为目标的http通道，即http下加入SSL层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。 2.http和https区别及优缺点 http是超文本传输协议，信息是明文传输，https协议比http协议安全，https是具有安全性的ssl加密传输协议，可防止数据在传输过程中被窃取、改变。确保数据的完整性 http协议的默认端口是80，https的默认端口是443 http的链接很简单，是无状态的。https的握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电 https的缓存不如http高效，会增加数据开销 https需要ca证书，费用较高，功能越强大的证书费用越高 SSL证书需要绑定IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。 3.https 协议的工作原理 客户端在使用https方式与web服务器通信时有以下几个步骤： 客户端使用https url访问服务器，则要求web服务器建立ssl链接 web服务器在接收到客户端的请求后，会将网站证书（证书中包含公钥）传输给客户端 客户端和web服务器端开始协商ssl链接的安全等级,也就是加密等级 客户端浏览器通过上访协商一致的安全等级，建立会话秘钥，然后通过网站的公钥来加密会话秘钥，并传送给网站 web服务器通过自己的私钥解密出会话秘钥 web服务器通过会话秘钥加密客户端之间的通信 "},{"title":"函数式编程范式","date":"2023-03-23T14:42:29.000Z","url":"/posts/42f6abb3.html","categories":[["js基础","/categories/js%E5%9F%BA%E7%A1%80/"]],"content":"高阶函数 可以把函数作为参数传递给另一个函数 可以把函数作为另一个函数的返回结果 函数作为返回值 常用的高阶函数高阶函数的意义 抽象可以帮屏蔽细节，只需要关注与我们的目标 高阶函数是用来抽象通用的问题 filter forEach map every some 闭包 函数和其周围的状态（词法环境）引用捆绑在一起形成闭包 可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员 闭包的本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员，因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员。 纯函数概念 纯函数：相同的输入永远会得到相同的输出，而且没有任何可观察的副作用 纯函数就类似数学中的函数，y&#x3D;f(x); 数组中的slice和splice，分别是纯函数和不纯的函数 splice返回数组中指定的部分，不会改变原数组 splice对数组进行操作返回该数组，会改变原数组 自定义纯函数 函数式编程不会保留计算结果，所以变量是不可变的（无状态的） 我们可以把一个函数的执行结果交给另一个函数去处理 纯函数的优势 可缓存 可测试 并行处理 在多线程环境下并行操作共享的内存数据很可能会出现意外情况 纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数 副作用 副作用让一个函数变得不纯，纯函数是根据相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用。 所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降不适合扩展和可重用性，同时副作用也会带来安全隐患，给程序带来不确定性，但是副作用不可能完全禁止，尽可能控制它们在可控范围内发剩。 3.柯里化 当一个函数有多个参数的时候先传递一部分参数（这部分参数以后永远不变） 然后返回一个新的函数接收剩余的参数，返回结果 4.PointFree我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只需要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数 不需要指明处理的数据 只需要合成运算过程 需要定义一些辅助的基运算函数 5.Functor (函子) 容器：包含值和值得变形关系（这个变形关系就是函数） 函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有 map 方法，map方法可以运行一个函数对值进行处理（变形关系） 总结 函数式编程的运算不直接操作值，而是由函子完成 函子就是一个实现了 map 契约的对象 我们可以把函子想象成一个盒子，这个盒子里封装了一个值 想要处理盒子中的值，我们需要给盒子的map方法传递一个处理值得函数（纯函数），由这个函数对值进行处理 最终map方法返回一个包含新值的盒子（函子） 5.MayBe (函子)MayBe函子的作用就是可以对外部的空值做处理（控制副作用在允许的范围） 6.Either (函子) 两者中的任何一个，类似于if...else的处理 异常会让函数变得不纯，Either函子可以用来做异常处理 7.IO函子 IO函子中 的_value是一个函数，这里是把函数作为值来处理 IO函子可以把不纯的动作存储到_value中，延迟执行这个不纯的操作（惰性执行），包装当前的操作纯 把不纯的操作交给调用者来处理 Task异步执行 异步任务的实现过于复杂，我们使用folktale中的 Task来掩饰 folktale 一个标准的函数试变成库 和lodash、ramda不同的是，没有 提供很多功能函数 什么是函数式编程函数式编程(function Programming, FP)是编程范式之一，我们常听说的变成范式还有面向过程编程、面向对象编程。 面向对象编程的思维方式：把现实世界中的事物抽象成程序世界中的类和对象，通过封装、继承和多态来演示事物和事件的联系 函数式编程的思维方式：把现实世界的事物和事物之间的联系抽象到程序世界（对运算过程进行抽象） 程序的本质：根据输入通过某中运算获得相应的输出，程序开发过程中会涉及很多有输入和输出的函数 x -&gt; f(联系、映射)-&gt; y, y&#x3D;f(x) 函数式编程中的函数指的不是程序中的函数（方法），而是数学中的函数即映射关系，例如：&#96;&#96;&#96;y &#x3D; sin(x)，x和y的关系 相同的输入始终要得到相同的输出（纯函数） 函数式编程用来描述数据（函数）之间的映射 函数是一等公民高阶函数闭包函数是一等公民 函数可以存储在变量中 函数可以作为参数 函数作为返回值 在javascript中函数就是一个普通的对象（可以通过 new function()），我们可以把函数存储到变量或者数组中，它还可以作为另一个函数的参数和返回值，甚至我们可以在程序运行的时候通过new function(`alert(1)`)来构造一个新的函数。 1.把函数赋值给变量 2. 高阶函数 可以把函数作为参数传递给另一个参数 可以把函数作为另一个函数的返回结果 2.1高阶函数-函数作为返回值 2.2高阶函数的意义意义： 抽象可以帮我们屏蔽细节，只需要关注我们的目标 高阶函数是用来抽象通用的问题 "},{"title":"eggConfig","date":"2023-03-23T14:40:12.000Z","url":"/posts/6268065.html","categories":[["node","/categories/node/"]],"content":"我们推荐直接使用脚手架，只需几条简单指令，即可快速生成项目 启动项目 目录结构 路由相关1. get传值 2. 4种配置方法 重定向1. ctx 2. 路由重定向 3.路由分组 控制器自定义 Controller 基类 此时在编写应用的 Controller 时，可以继承 BaseController，直接使用基类上的方法： 模板引擎1. 安装和使用ejs（1）安装 （2）配置：&#x2F;configconfig&#x2F;config.default.js （3）使用app&#x2F;controller app&#x2F;view&#x2F;index.html 服务（模型）控制器调用home 模型的test 方法 模型之间相互调用（同上） 模型和数据库配置和创建迁移文件配置 安装并配置egg-sequelize插件（它会辅助我们将定义好的 Model 对象加载到 app 和 ctx 上）和mysql2模块： 在config/plugin.js 中引入 egg-sequelize 插件 在config/config.default.js sequelize 提供了sequelize-cli工具来实现Migrations，我们也可以在 egg 项目中引入 sequelize-cli。 egg 项目中，我们希望将所有数据库 Migrations 相关的内容都放在database目录下，所以我们在项目根目录下新建一个.sequelizerc配置文件： 初始化 Migrations 配置文件和目录 行完后会生成database/config.json文件和database/migrations目录，我们修改一下database/config.json中的内容，将其改成我们项目中使用的数据库配置： 创建数据库 创建数据迁移表 执行完命令后，会在database &#x2F; migrations &#x2F; 目录下生成数据表迁移文件，然后定义 执行 migrate 进行数据库变更 已创建新增字段 创建迁移文件： 执行完命令后，会在database &#x2F; migrations &#x2F; 目录下生成数据表迁移文件，然后定义 执行 migrate 进行数据库变更 创建模型 这个 Model 就可以在 Controller 和 Service 中通过 app.model.User 或者 ctx.model.User 访问到了，例如我们编写 app/controller/users.js： 最后我们将这个 controller 挂载到路由上： 针对 users 表的 CURD 操作的接口就开发完了 模型其他参数 sequelize 命令 命令 含义 sequelize db:migrate 运行迁移文件 sequelize db:migrate:status 列出所有迁移的状态 sequelize db:migrate:undo 隔离数据库：迁移：撤消 sequelize db:migrate:undo:all 还原所有运行的迁移 sequelize db:create 创建由配置指定的数据库 sequelize db:drop 删除由配置指定的数据库 外键约束（重要） 创建第一个种子假设我们希望在默认情况下将一些数据插入到几个表中. 如果我们跟进前面的例子,我们可以考虑为 User 表创建演示用户. 要管理所有数据迁移,你可以使用 seeders. 种子文件是数据的一些变化,可用于使用样本数据或测试数据填充数据库表. 让我们创建一个种子文件,它会将一个演示用户添加到我们的 User 表中. 这个命令将会在 seeders 文件夹中创建一个种子文件.文件名看起来像是 XXXXXXXXXXXXXX-demo-user.js,它遵循相同的 up/down 语义,如迁移文件. 现在我们应该编辑这个文件,将演示用户插入User表. 运行种子在上一步中,你创建了一个种子文件. 但它还没有保存到数据库. 为此,我们需要运行一个简单的命令. 这将执行该种子文件,你将有一个演示用户插入 User 表. 注意: seeders 执行不会存储在任何使用 SequelizeMeta 表的迁移的地方. 如果你想覆盖这个,请阅读 存储 部分 撤销种子Seeders 如果使用了任何存储那么就可以被撤消. 有两个可用的命令 如果你想撤消最近的种子 如果你想撤消特定的种子 如果你想撤消所有的种子 关联操作一对一模型层： 控制器调用： 一对多 多对多 关联常用操作 获取器和修改器模型层 控制器层 模型钩子模型层 查询主键查询 查找不存在则创建方法 findOrCreate 可用于检查数据库中是否已存在某个元素. 如果是这种情况,则该方法将生成相应的实例. 如果元素不存在,将会被创建. 如果是这种情况,则该方法将导致相应的实例. 如果元素不存在,将会被创建. 假设我们有一个空的数据库,一个 User 模型有一个 username 和 job. 代码创建了一个新的实例. 所以当我们已经有一个实例了 … 现有条目将不会更改. 看到第二个用户的 “job”,并且实际上创建操作是假的. 查找并计数findAndCountAll - 在数据库中搜索多个元素,返回数据和总计数 这是一个方便的方法,它结合了 findAll 和 count(见下文),当处理与分页相关的查询时,这是有用的,你想用 limit 和 offset 检索数据,但也需要知道总数与查询匹配的记录数: 处理程序成功将始终接收具有两个属性的对象: count - 一个整数,总数记录匹配where语句和关联的其它过滤器 rows - 一个数组对象,记录在limit和offset范围内匹配where语句和关联的其它过滤器, 它支持 include. 只有标记为 required 的 include 将被添加到计数部分: 假设你想查找附有个人资料的所有用户: 因为 Profile 的 include 有 required 设置,这将导致内部连接,并且只有具有 profile 的用户将被计数. 如果我们从 include 中删除required,那么有和没有 profile 的用户都将被计数. 在include中添加一个 where 语句会自动使它成为 required:&#96;&#96; 上面的查询只会对具有 active profile 的用户进行计数,因为在将 where 语句添加到 include 时,required 被隐式设置为 true. 传递给 findAndCountAll 的 options 对象与 findAll 相同(如下所述). 查询多个（常用） 复合过滤 &#x2F; OR &#x2F; NOT 查询你可以使用多层嵌套的 AND,OR 和 NOT 条件进行一个复合的 where 查询. 为了做到这一点,你可以使用 or , and 或 not 运算符: 这两段代码将生成以下内容: not 示例: 将生成: 用限制,偏移,顺序和分组操作数据集要获取更多相关数据,可以使用限制,偏移,顺序和分组: 分组和排序的语法是相同的,所以下面只用一个单独的例子来解释分组,而其余的则是排序. 你下面看到的所有内容也可以对分组进行 请注意,在上述两个示例中,提供的字符串逐字插入到查询中,所以不会转义列名称. 当你向 order &#x2F; group 提供字符串时,将始终如此. 如果要转义列名,你应该提供一个参数数组,即使你只想通过单个列进行 order &#x2F; group 回顾一下,order &#x2F; group数组的元素可以是以下内容: String - 将被引用 Array - 第一个元素将被引用,第二个将被逐字地追加 Object - raw 将被添加逐字引用 如果未设置 raw,一切都被忽略,查询将失败 Sequelize.fn 和 Sequelize.col 返回函数和引用的列名 字段过滤想要只选择某些属性,可以使用 attributes 选项. 通常是传递一个数组: 属性可以使用嵌套数组来重命名: 也可以使用 sequelize.fn 来进行聚合: 使用聚合功能时,必须给它一个别名,以便能够从模型中访问它. 在上面的例子中,你可以使用 instance.get(&#39;no_hats&#39;) 获得帽子数量. 有时,如果你只想添加聚合,则列出模型的所有属性可能令人厌烦: 同样,它也可以排除一些指定的表字段: Where无论你是通过 findAll&#x2F;find 或批量 updates&#x2F;destroys 进行查询,都可以传递一个 where 对象来过滤查询. where 通常用 attribute:value 键值对获取一个对象,其中 value 可以是匹配等式的数据或其他运算符的键值对象. 也可以通过嵌套 or 和 and 运算符 的集合来生成复杂的 AND&#x2F;OR 条件. 基础 操作符Sequelize 可用于创建更复杂比较的符号运算符 - 范围选项所有操作符都支持支持的范围类型查询. 请记住,提供的范围值也可以定义绑定的 inclusion&#x2F;exclusion. 组合 关系 &#x2F; 关联 分页 &#x2F; 限制 排序order 需要一个条目的数组来排序查询或者一个 sequelize 方法.一般来说,你将要使用任一属性的 tuple&#x2F;array,并确定排序的正反方向. count - 计算数据库中元素的出现次数还有一种数据库对象计数的方法: max - 获取特定表中特定属性的最大值这里是获取属性的最大值的方法: min - 获取特定表中特定属性的最小值这里是获取属性的最小值的方法: sum - 特定属性的值求和为了计算表的特定列的总和,可以使用“sum”方法. 预加载当你从数据库检索数据时,也想同时获得与之相关联的查询,这被称为预加载.这个基本思路就是当你调用 find 或 findAll 时使用 include 属性.让我们假设以下设置: 首先,让我们用它们的关联 user 加载所有的 task. 请注意,访问者(结果实例中的 User 属性)是单数形式,因为关联是一对一的. 接下来的事情:用多对一的关联加载数据！ 请注意,访问者(结果实例中的 Tasks 属性)是复数形式,因为关联是多对一的. 如果关联是别名的(使用 as 参数),则在包含模型时必须指定此别名. 注意用户的 Tool 如何被别名为 Instruments. 为了获得正确的权限,你必须指定要加载的模型以及别名: 你还可以通过指定与关联别名匹配的字符串来包含别名: 当预加载时,我们也可以使用 where 过滤关联的模型. 这将返回 Tool 模型中所有与 where 语句匹配的行的User. 当使用 include.where 过滤一个预加载的模型时,include.required 被隐式设置为 true. 这意味着内部联接完成返回具有任何匹配子项的父模型. 使用预加载模型的顶层 WHERE将模型的 WHERE 条件从 ON 条件的 include 模式移动到顶层,你可以使用 &#39;$nested.column$&#39; 语法: 包括所有要包含所有属性,你可以使用 all:true 传递单个对象: 包括软删除的记录如果想要加载软删除的记录,可以通过将 include.paranoid 设置为 false 来实现 排序预加载关联在一对多关系的情况下. 在多对多关系的情况下,你还可以通过表中的属性进行排序. 嵌套预加载你可以使用嵌套的预加载来加载相关模型的所有相关模型: 这将产生一个外连接. 但是,相关模型上的 where 语句将创建一个内部连接,并仅返回具有匹配子模型的实例. 要返回所有父实例,你应该添加 required: false. 以上查询将返回所有用户及其所有乐器,但只会返回与 Woodstock Music School 相关的老师. 包括所有也支持嵌套加载: 新增字段限制 新增单个 批量新增 修改字段限制 单个修改 批量修改 递增 递减 删除软删除模型中配置 查询包括软删除内容 彻底删除如果 paranoid 选项为 true,则不会删除该对象,而将 deletedAt 列设置为当前时间戳. 要强制删除,可以将 force: true 传递给 destroy 调用: 在 paranoid 模式下对象被软删除后,在强制删除旧实例之前,你将无法使用相同的主键创建新实例. 恢复软删除的实例如果你使用 paranoid:true 软删除了模型的实例,之后想要撤消删除,请使用 restore 方法: 条件删除 批量删除 重载实例如果你需要让你的实例同步,你可以使用 reload 方法. 它将从数据库中获取当前数据,并覆盖调用该方法的模型的属性. 模型自定义方法 Scopes - 作用域（重点）作用域允许你定义常用查询,以便以后轻松使用. 作用域可以包括与常规查找器 where, include, limit 等所有相同的属性. 定义作用域在模型定义中定义,可以是finder对象或返回finder对象的函数,除了默认作用域,该作用域只能是一个对象: 通过调用 addScope 定义模型后,还可以添加作用域. 这对于具有包含的作用域特别有用,其中在定义其他模型时可能不会定义 include 中的模型. 始终应用默认作用域. 这意味着,通过上面的模型定义,Project.findAll() 将创建以下查询: 可以通过调用 .unscoped(), .scope(null) 或通过调用另一个作用域来删除默认作用域: 还可以在作用域定义中包含作用域模型. 这让你避免重复 include,attributes 或 where 定义. 使用上面的例子,并在包含的用户模型中调用 active 作用域(而不是直接在该 include 对象中指定条件): 使用通过在模型定义上调用 .scope 来应用作用域,传递一个或多个作用域的名称. .scope 返回一个全功能的模型实例,它具有所有常规的方法:.findAll,.update,.count,.destroy等等.你可以保存这个模型实例并稍后再次使用: 作用域适用于 .find, .findAll, .count, .update, .increment 和 .destroy. 可以通过两种方式调用作为函数的作用域. 如果作用域没有任何参数,它可以正常调用. 如果作用域采用参数,则传递一个对象: 合并通过将作用域数组传递到 .scope 或通过将作用域作为连续参数传递,可以同时应用多个作用域. 如果要将其他作用域与默认作用域一起应用,请将键 defaultScope 传递给 .scope: 当调用多个作用域时,后续作用域的键将覆盖以前的作用域(类似于 Object.assign),除了where和include,它们将被合并. 考虑两个作用域: 调用 .scope(&#39;scope1&#39;, &#39;scope2&#39;) 将产生以下查询 注意 scope2 将覆盖 limit 和 age,而 firstName 被保留. limit,offset,order,paranoid,lock和raw字段被覆盖,而where被浅层合并(意味着相同的键将被覆盖). include 的合并策略将在后面讨论. 请注意,多个应用作用域的 attributes 键以这样的方式合并,即始终保留 attributes.exclude. 这允许合并多个作用域,并且永远不会泄漏最终作用域内的敏感字段. 将查找对象直接传递给作用域模型上的findAll(和类似的查找程序)时,适用相同的合并逻辑: 这里的 deleted 作用域与 finder 合并. 如果我们要将 where: &#123; firstName: &#39;john&#39;, deleted: false &#125; 传递给 finder,那么 deleted 作用域将被覆盖. 合并 includeInclude 是根据包含的模型递归合并的. 这是一个非常强大的合并,在 v5 上添加,并通过示例更好地理解. 考虑四种模型:Foo,Bar,Baz和Qux,具有如下多种关联: 现在,考虑Foo上定义的以下四个作用域: 这四个作用域可以很容易地深度合并,例如通过调用 Foo.scope(&#39;includeEverything&#39;, &#39;limitedBars&#39;, &#39;limitedBazs&#39;, &#39;excludeBazName&#39;).findAll(),这完全等同于调用以下内容: 观察四个作用域如何合并为一个. 根据所包含的模型合并作用域的include. 如果一个作用域包括模型A而另一个作用域包括模型B,则合并结果将包括模型A和B.另一方面,如果两个作用域包括相同的模型A,但具有不同的参数(例如嵌套include或其他属性) ,这些将以递归方式合并,如上所示. 无论应用于作用域的顺序如何,上面说明的合并都以完全相同的方式工作. 如果某个参数由两个不同的作用域设置,那么只会该顺序产生差异 - 这不是上述示例的情况,因为每个作用域都做了不同的事情. 这种合并策略的工作方式与传递给.findAll,.findOne等的参数完全相同. 关联Sequelize 与关联有两个不同但相关的作用域概念. 差异是微妙但重要的: 关联作用域 允许你在获取和设置关联时指定默认属性 - 在实现多态关联时很有用. 当使用get,set,add和create相关联的模型函数时,这个作用域仅在两个模型之间的关联上被调用 关联模型上的作用域 允许你在获取关联时应用默认和其他作用域,并允许你在创建关联时传递作用域模型. 这些作用域都适用于模型上的常规查找和通过关联查找. 举个例子,思考模型Post和Comment. Comment与其他几个模型(图像,视频等)相关联,Comment和其他模型之间的关联是多态的,这意味着除了外键 commentable_id 之外,注释还存储一个commentable列. 可以使用 association scope 来实现多态关联: 当调用 post.getComments() 时,这将自动添加 WHERE commentable = &#39;post&#39;. 类似地,当向帖子添加新的注释时,commentable 会自动设置为 &#39;post&#39;. 关联作用域是为了存活于后台,没有程序员不必担心 - 它不能被禁用. 有关更完整的多态性示例,请参阅 关联作用域 那么考虑那个Post的默认作用域只显示活动的帖子:where: &#123; active: true &#125;. 该作用域存在于相关联的模型(Post)上,而不是像commentable 作用域那样在关联上. 就像在调用Post.findAll() 时一样应用默认作用域,当调用 User.getPosts() 时,它也会被应用 - 这只会返回该用户的活动帖子. 要禁用默认作用域,将 scope: null 传递给 getter: User.getPosts(&#123; scope: null &#125;). 同样,如果要应用其他作用域,请像这样: 如果要为关联模型上的作用域创建快捷方式,可以将作用域模型传递给关联. 考虑一个快捷方式来获取用户所有已删除的帖子: 扩展extend&#x2F;helper.js 模板中调用 其他地方调用 中间件1. 定义app&#x2F;middleware&#x2F;getIp.js 2. 配置config&#x2F;config.default.js（配置全局中间件，所有路由都会调用） 3. 使用路由中使用app&#x2F;router.js 使用 Koa 的中间件（gzip压缩）大大提高网站的访问速度（非常有效） 以 koa-compress 为例，在 Koa 中使用时: 我们按照框架的规范来在应用中加载这个 Koa 的中间件： 表单提交postapp&#x2F;controller&#x2F;home.js app&#x2F;view&#x2F;post.html app&#x2F;router.js cookie session 定时任务 API1. contextcurl 常用插件缓存 验证 加密 前端访问：header头添加： "},{"title":"css","date":"2023-03-23T14:39:08.000Z","url":"/posts/78cea6d8.html","categories":[["通用","/categories/%E9%80%9A%E7%94%A8/"]],"content":"公共样式 "},{"title":"react项目基本配置","date":"2023-03-23T14:37:06.000Z","url":"/posts/84d7d56.html","categories":[["react项目配置","/categories/react%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/"]],"content":"前言目前主要使用的脚手架是create-react-app这个脚手架，因为不想使用npm eject将脚手架隐藏的配置文件暴露出来，那么有没有其他办法实现一些基本的配置呢？ 主要配置eslint统一团队内的代码风格，还有呢就是使用less module，修改项目的主题色，这些配置。 第一步安装antd提供的craco 然后修改package.json 第二步 创建craco.config.js配置less module 然后在craco.config.js添加 第三步 创建postcss.config.js 因为在项目中主要使用的TypeScript，所以还要配置一下tsconfig.json文件 我们需要新建一个tsconfig.base.json 内容 修改tsconfig,json 第四步 配置eslint 安装完成之后，新建.eslintrc .eslintrc 不要急，到这里还没完， 需要新建一个.editorconfig配置文件 .editorconfig 最后附上我的vscode中的settings.json的配置settings.json 好了，到这里就结束了~~"},{"title":"浏览器篇","date":"2023-03-23T14:35:52.000Z","url":"/posts/da130f3a.html","categories":[["面试题","/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"]],"content":"从输入URL到页面加载的全过程 首先在浏览器中输入url 查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。 浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求； 操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录（保存最近的DNS查询缓存）； 路由器缓存： 如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存； lsp缓存：若上述均失败，继续向ISP搜索。 DNS域名解析：浏览器向DNS服务器发起请求，解析该url中的域名对应的IP地址.DNS服务器是基于UDP的，因此会用到UDP协议 建立TCP链接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP链接 发起HTTP请求：浏览器发起读取文件的HTTP请求，该请求报文作为TCP三次握手的第三次数据发送给给服务器 服务器响应请求并返回结果：服务器对浏览器的请求作出响应，并把对应的html文件发送给浏览器 关闭TCP链接：通过四次回收释放TCP链接 浏览器渲染：客户端（浏览器）解析HTML文件并渲染出来，浏览器接收到数据包后的解析流程为： 构建DOM树：词法分析然后解析成DOM树（don tree），是由DOM元素及属性节点组成，树的根是document对象 构建CSS规则树：生成CSS规则树（CSS Rule Tree） 构建render树：web浏览器会将DOM和CSSOM结合，并构建出渲染树（render Tree） 布局（layout）：计算出每个节点在屏幕中的位置 绘制（Painting）：遍历render树，并使用 UI后端层绘制每个节点。 js引擎解析过程： 调用js引擎执行js代码（js的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链，回收机制等） 创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的document对象上。当关闭网页或者浏览器时，全局执行环境会被销毁 加载文件：完成js引擎分析它的语法和词法是否合法，如果合法则进入预编译 预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为undefined；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给它，（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方已经在es6中解决了，函数提升还是存在的 解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在es5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string int这样的就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。js作用域其实就是这样的执行机制实现的 浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 强制缓存```Expires 和 Cache-Control```，其中```Cache-Control```优先级比```Expires```高。 当一个javascript文件被加载时是否会阻塞其他javascript文件或者其他文件的加载呢？ 答案是：各种浏览器的低版本的处理是当一个js文件在加载时，会同时阻塞页面其他文件的加载。（包括其他的js文件）但是ie8、Firfox3.5、Safari 4和Chrome 2都允许并行下载javascript文件，但是呢，javascript下载过程仍然会阻塞其他资源的下载，比如图片。尽管javascript脚本的下载过程不会相互影响，但页面仍然必须等待所有的javascript代码下载并执行完成才能继续。 2. 优化的方法（技巧） 由于脚本会阻塞页面其他资源的下载，因此我们一般将所有的&lt;script&gt;标签放到&lt;body&gt;标签的底部，已尽量减少对整个页面下载的影响。 将能合并的js文件合并 无阻塞脚本 现在比较常用的方法就是动态加载执行脚本。原理是DOM,可以通过js动态的创建HTML中所有的内容，其根本在于&lt;script&gt;标签与页面中其他元素并无差异，都能通过DOM引用，都能在文档中移动，删除和创建。文件在该&lt;script&gt;元素被添加到页面时开始现在，它不会阻止其他文件下载，只在执行阶段阻塞渲染。这种方法并不是说它在执行不会阻塞其他javascript代码，而是不会阻塞其他资源的下载等其他任务。 "},{"title":"javascript基本算法","date":"2023-03-23T14:34:48.000Z","url":"/posts/9505ccb9.html","categories":[["随笔","/categories/%E9%9A%8F%E7%AC%94/"]],"content":"前言在前端面试的过程中我们必须要会的一个技能就是算法，一般来说面试中高级前端工程师的时候会要求会算法，至于校招考不考算法我就不知道了，话不多说就让我们开始吧！ 时间复杂度O(1) O(n) O(n) * O(n) &#x3D; O(n^2) O(logN) 空间复杂度简述： 1、一个函数，用大O表示，比如O(1)、O(N)、O(n^2)…… 2、算法唉运行过程中临时占用存储空间大小的量度 O(1) O(n) O(n^2) 栈简介栈是什么？ 一个后进先出的数据结构 应用场景 十进制转二进制、判断z字符串的括号是否有效、函数调用堆栈 例子给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。思路符合后进先出考虑用栈 新建一个栈 扫描字符串，遇左括号入栈，遇到和栈顶括号类型匹配的有括号出栈，类型不符合之间判定为不合法 js中的函数调用堆栈 链表简介链表是什么？ 多个元素组成的列表 元素存储不连续，用next指针连在一起 数组VS链表 数组：增删非首尾元素时往往需要移动元素 链表：增删首尾元素，不需要移动元素，只需要更改next指向即可 JS中的链表 js中没有链表 可以用Object模拟链表 leetCode 237 删除链表中的节点 LeetCode 206 反转链表思路 反转两个节点：将n+1的next指向n 反转多个节点：双指针遍历链表 "},{"title":"htmlOrcss","date":"2023-03-23T14:24:24.000Z","url":"/posts/20e59239.html","categories":[["html&css","/categories/html-css/"]],"content":"前言回顾一下面试中常问的html和css，温故而知新 DOCTYPE(⽂档类型) 的作⽤DOCTYPE是html5中一种标准通用标记语言的文档类型声明，它的目的是告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对css代码甚至JavaScript脚本的解析。 注意：必须声明在HTML文件中的第一行 浏览器渲染页面的两种模式（document.compatMode） css1Compat: 标准模式（Strick mode）默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。 BackCompat: 怪异模式(混杂模式)(Quick mode)，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。 你知道html中哪些语义化标签 为什么会有语义化标签出现 利于开发：结构清晰、可读性高、方便维护 利于SEO：方便爬虫根据语义标签确定页面结构和关键字的权重 title、description、keyword meta viewport是做什么的，怎么写？禁止页面在移动端缩放 name为viewport表示移动设备使用 content定义了viewport的属性： width表示宽度为设备宽度（兼容苹果） initial-scale表示设备与视口的缩放比率（兼容IE） 你用过哪些 meta 标签属性 其中，content参数有一下六种 width viewport: 宽度(数值&#x2F;device-width) height viewport: 高度(数值&#x2F;device-height) initial-scale: 初始缩放比例 maximum-scale: 最大缩放比例 minimum-scale: 最小缩放比例 user-scalable: 是否允许用户缩放(yes&#x2F;no） 搜索引擎索引方式： all：文件将被检索，且页面上的链接可以被查询； none：文件将不被检索，且页面上的链接不可以被查询； index：文件将被检索 follow：页面上的链接可以被查询； noindex：文件将不被检索 nofollow：页面上的链接不可以被查询。 script标签中defer和async的区别如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。 defer和async属性都是去异步加载外部的JS脚本文件，他们都不会阻塞页面的解析，区别如下： 执行顺序： 多个带async属性的标签，不能保证加载的顺序 多个带defer属性的标签，按照加载顺序执行 脚本是否并行执行 async属性，表示后续文档的加载和执行与js脚本的加载和执行是并行执行的，即异步执行 defer属性，加载后续文档的过程和js脚本的加载是并行的，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前 HTML、XML、XHTML 的区别 HTML：超文本标记语言，是语法较为松散、不严的web语言； XML：可扩展的标记语言，主要用于存储数据和结构，可扩展 XHTML：可扩展的超文本标记语言，基于XML，作用与HTML类似，但语法更严格 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 行内元素： a、b、span、img、input、select、strong 块级元素：div、ul、li、dl、dt、dd、p 空元素：&lt;br&gt;、&lt;hr&gt;、&lt;img /&gt;、&lt;link/&gt; 标签上title属性与alt属性的区别是什么 alt是为了在图片未能正常显示时（屏幕阅读器）给予文字说明。且长度必须少于100个英文字符或者用户必须保证替换文字尽可能的短。 title属性为设置该属性的元素提供建议性的信息。使用title属性提供非本质的额外信息。 head 标签有什么作用，其中什么标签必不可少？标签用于定义文档的头部，它是所有头部元素的容器。 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。 文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。 下面这些标签可用在 head 部分：&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, &lt;title&gt;。 其中 &lt;title&gt; 定义文档的标题，它是 head 部分中唯一必需的元素。 src与href有什么区别src用于替换当前元素；href用于在当前文档和引用资源之间确立联系； src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置； 而href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接。 为什么利用多个域名来存储网站资源会更有效 CDN缓存更加方便 突破浏览器并发限制； 节约cookie宽带； 节约主域名的连接数，优化页面下响应速度； 防止不必要的安全问题； 对比一下cookie和sessioncookie和session都是用来跟踪浏览器用户身份的会话方式。 区别: 1.保持状态：cookie保存在浏览器端，session保存在服务器端 2.使用方式： cookie机制： 如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称会话cookie。 如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期时间结束才消失。 Cookie是服务器发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它。 session机制： 当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。 通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url) 进行实现；API对encodeURL的结束为，当浏览器支持Cookie时，url不做任何处理；当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。3.存储内容： cookie只能保存字符串类型，以文本的方式； session通过类似与Hashtable的数据结构来保存，能支持任何类型的对象(session中可含有多个对象)。4.存储的大小： cookie：单个cookie保存的数据不能超过4kb； session大小没有限制。5.安全性： cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获； session的安全性大于cookie。 原因如下： sessionID存储在cookie中，若要攻破session首先要攻破cookie； sessionID是要有人登录，或者启动session_start才会有，所以攻破cookie也不一定能得到sessionID； 第二次启动session_start后，前一次的sessionID就是失效了，session过期后，sessionID也随之失效。 sessionID是加密的 6.缺点： cookie： 大小受限 用户可以操作（禁用）cookie，使功能受限 安全性较低 有些状态不可能保存在客户端。 每次访问都要传送cookie给服务器，浪费带宽。 cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。 session： Session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。 依赖于cookie（sessionID保存在cookie），如果禁用cookie，则要使用URL重写，不安全。 创建Session变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以，过度使用session变量将会导致代码不可读而且不好维护。 HTML5的十大新特性 语义标签 增强型表单 视频和音频 Canvas绘图 SVG绘图 地理定位 Geolocation 拖放API Web Worker Web Storage WebSocket 说一下 web worker在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。 如何创建 web worker： 检测浏览器对于 web worker 的支持性 创建 web worker 文件（js，回传函数等） 创建 web worker 对象 说一下 HTML5 drag API dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。 darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。 dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。 dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。 dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。 drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。 dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。 "}]